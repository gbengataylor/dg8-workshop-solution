<!DOCTYPE html>
<!-- saved from url=(0099)http://web-guides.apps.cluster-cph-b051.cph-b051.example.opentlc.com/workshop/dg8-workshop/complete -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>
      Red Hat Data Grid - From zero to hero
  </title>
  <meta name="csrf-param" content="authenticity_token">
<meta name="csrf-token" content="jnunuysE1EJJ2b+iP9EnoFEo3/L3xQKYmZKjyzcMQsGPKY9yV5CLNF0kfckZtN05U5wSu1Dy17EfcK0ttBNcyw==">
  <link rel="stylesheet" media="all" href="./Red Hat Data Grid - From zero to hero_files/application-dcf5640dabe7c086c5db76b2e378b4def3309902bc32af61ab63094a23e1730b.css" data-turbolinks-track="reload">
  <script src="./Red Hat Data Grid - From zero to hero_files/application-1763c4134299cf1911a383dd8d9b23b574b429196c500fbba1a010629fc4c558.js" data-turbolinks-track="reload"></script><style type="text/css">/* Chart.js */
@-webkit-keyframes chartjs-render-animation{from{opacity:0.99}to{opacity:1}}@keyframes chartjs-render-animation{from{opacity:0.99}to{opacity:1}}.chartjs-render-monitor{-webkit-animation:chartjs-render-animation 0.001s;animation:chartjs-render-animation 0.001s;}</style>
<script type="text/javascript">
function gowithuser() {
    window.location.search = ('&userid=' + document.getElementById('useridfield').value);
}
function recycle() {
  window.location.search = ('&userid=reset');
}
</script></head>



<body class="vsc-initialized">
<nav class="navbar fixed-top navbar-expand-lg navbar-dark bg-dark">
  <div class="container-fluid d-flex justify-content-start">
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarContent">
      <span class="navbar-toggler-icon"></span>
    </button>
      <a class="navbar-brand mb-0 h1" href="http://web-guides.apps.cluster-cph-b051.cph-b051.example.opentlc.com/workshop/dg8-workshop" id="workshopName">Red Hat Data Grid - From zero to hero</a>
  </div>
</nav>

<script type="application/javascript">
    if (App.hasOwnProperty('subscription_id')) {
        App.cable.subscriptions.remove(App.subscription_id);
    }

    App.subscription_id = App.report_page_view('dg8-workshop#complete', 'c62eca59-3cd8-4c12-8b06-113ba2e1adb2');
</script>

<main class="container-fluid">
  <div class="row">
    <div class="col-md-12">
        <h2>Preface</h2>
        <div class="sect1">
<h2 id="_preface_what_happens_when_you_run_your_applications_distributed_scaled_and_in_the_cloud">Preface - What happens when you run your applications distributed, scaled and in the cloud …​</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You are a developer or an architect creating world-class applications and solutions. Well, all applications don’t necessarily live in just one box, and for the recent past, Cloud is not just one more computer but a lot more. All applications use a network to speak to each other, whether they speak to a database, a web service or storage, or other services. That’s the world we all live in!</p>
</div>
<div class="paragraph">
<p>Creating a distributed application means you care about latency, performance, and, most importantly, the responsiveness to your end-users. End users could be systems or humans; whats important is that you have a timely and consistent response. If that’s the challenging world we all live in, don’t worry, there are a lot many things one can do to optimize the stack. Most importantly, this workshop focuses on one thing i.e. Red Hat Data Grid.</p>
</div>
<div class="paragraph">
<p>So what is Red Hat Data Grid?
Red Hat Data Grid 8.0 provides a distributed in-memory, NoSQL datastore solution. Your applications can access, process, and analyze data at in-memory speed to deliver a superior user experience. Whether you are using legacy applications or a new breed of microservices and functions, Red Hat Data Grid 8.0 will enable your applications to perform better with its in-memory solution.</p>
</div>
<div class="paragraph">
<p>This lab offers attendees an intro-level, hands-on session with Red Hat Data Grid, which uses the infinispan components under the hood. You will see these names interchangeably used and they both mean the same, since Inifinispan is an integral component in the Red Hat Data Grid. From the first line of code, to making services, to consuming them and finally to assembling everything together and deploying it on Openshift. It illustrates what Cache is, how to program with a distributed cache, and how to build applications and best practises on designing applications with Cache.</p>
</div>
<div class="paragraph">
<p>Deploying and maintaining microservices is hard. Much harder than maintaining a monolith. The are many moving pieces that can change / evolve / crash at anytime. To help us deploying our microservices, we are going to use Kubernetes. Kubernetes (commonly referred to as "K8s") is an open-source system for automating deployment, scaling and management of containerized applications that was originally designed by Google and donated to the Cloud Native Computing Foundation. It aims to provide a "platform for automating deployment, scaling, and operations of application containers across clusters of hosts". In this lab, we are using a specific distribution of K8S named OpenShift that provide a few set of features very useful to maintain our microservices. It’s NOT required to deploy Vert.x applications on top of Kubernetes. Bare metal is generally fine. We use Kubernetes in this lab because of the complexity involved when dealing with multiple microservices, their updates, downtimes and so on.</p>
</div>
<div class="paragraph">
<p>This is a BYOL (Bring Your Own Laptop) session. You will be provided with a CodeReady Workspace, an Openshift environment all pre-provisioned. If you prefer to run locally on your own laptop, you can do development on your own laptop, but you will need to use the provided Openshift environment as Operators installed for you are already setup there. So bring your Windows, OSX, or Linux laptop. You need JDK 8+ on your machine, and Apache Maven (3.5+).</p>
</div>
<div class="paragraph">
<p>What you are going to learn:</p>
</div>
<div class="paragraph">
<p>What is Red Hat Data Grid 8.0</p>
</div>
<div class="paragraph">
<p>What is a Cache, and how to start with the common usecases</p>
</div>
<div class="paragraph">
<p>What is an Embedded Cache</p>
</div>
<div class="paragraph">
<p>What is Clustering in a Cache scenario and how it works</p>
</div>
<div class="paragraph">
<p>What is a Remote Cache and how to take benefit of Red Hat Data Grid</p>
</div>
<div class="paragraph">
<p>You will build applications with known frameworks like Quarkus and Spring</p>
</div>
<div class="paragraph">
<p>You will learn hot to use Red Hat Data Grid server REST API.</p>
</div>
<div class="paragraph">
<p>You will learn how to externalize sessions</p>
</div>
<div class="paragraph">
<p>And many more…​</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Don’t expect to complete this lab in 3 hours, it will take you a lot more. But that’s not a big deal. Pick the topic
 you want, learn what you want, and come back later to learn more.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
        <hr>
        <h2>Setting up</h2>
        <div class="sect1">
<h2 id="_first_step_set_your_username">First Step: Set Your Username!</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the above box, enter the user ID you were assigned:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/setuser.png" alt="Set User ID above" width="900">
</div>
</div>
<div class="paragraph">
<p>This will customize the links and copy/paste code for this workshop. If you accidently type the wrong username, just click the green recycle icon to reset it.</p>
</div>
<div class="paragraph">
<p>Throughout this lab you’ll discover how Quarkus can make your development of cloud native apps faster and more productive.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_click_to_copy">Click-to-Copy</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You will see various code and command blocks throughout these exercises which can be copy/pasted directly by clicking anywhere on the block of text:</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/* A sample Java snippet that you can copy/paste by clicking */</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">CopyMeDirectly</span> {
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">"</span><span class="content">You can copy this whole class with a click!</span><span class="delimiter">"</span></span>);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Simply click once and the whole block is copied to your clipboard, ready to be pasted with kbd:[CTRL+V] (or kbd:[Command+V] on Mac OS).</p>
</div>
<div class="paragraph">
<p>There are also Linux shell commands that can also be copied and pasted into a Terminal in your Development Environment:</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">echo "This is a bash shell command that you can copy/paste by clicking"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_workshop_environment_you_are_using">The Workshop Environment You Are Using</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Your workshop environment consists of several components which have been pre-installed and are ready to use. Depending on which parts of the workshop you’re doing, you will use one or more of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.openshift.com/" target="_blank" rel="noopener">Red Hat OpenShift</a> - You’ll use one or more )<strong>projects</strong> (Kubernetes namespaces) that are your own and are isolated from other workshop students</p>
</li>
<li>
<p><a href="https://developers.redhat.com/products/codeready-workspaces/overview" target="_blank" rel="noopener">Red Hat CodeReady Workspaces</a> - based on <strong>Eclipse Che</strong>, it’s a cloud-based, in-browser IDE (similar to IntelliJ IDEA, VSCode, Eclipse IDE). You’ve been provisioned your own personal workspace for use with this workshop. You’ll write, test, and deploy code from here.</p>
</li>
<li>
<p><a href="https://www.redhat.com/en/products/runtimes" target="_blank" rel="noopener">Red Hat Runtimes</a> - a collection of cloud-native runtimes like Spring Boot, Node.js, and <a href="https://quarkus.io/" target="_blank" rel="noopener">Quarkus</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You’ll be provided clickable URLs throughout the workshop to access the services that have been installed for you.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_complete_this_workshop">How to complete this workshop</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Click the "Next &gt;" button at the bottom to advance to the next topic. You can also use the menu on the left to move around the instructions at will.</p>
</div>
<div class="paragraph">
<p>Good luck, and let’s get started!</p>
</div>
</div>
</div>
        <hr>
        <h2>DataGrid in 10 mins</h2>
        <div class="sect1">
<h2 id="_datgrid_8_0_in_10_minutes">DatGrid 8.0 in 10 minutes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The latest update to Red Hat Runtimes is with the release of Red Hat Data Grid 8.0, which provides a distributed in-memory, NoSQL datastore solution. Your applications can access, process, and analyze data at in-memory speed to deliver a superior user experience. Whether you are using legacy applications or a new breed of microservices and functions, Red Hat Data Grid 8.0 will enable the journey to Open Hybrid Cloud. Data Grid is built from the Infinispan open-source software project and is available to deploy as an embedded library, as a standalone server, or as a containerized application on Red Hat OpenShift Container Platform.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/dg8.png" alt="Red Hat Data Grid 8.0" width="900">
</div>
</div>
<div class="sect2">
<h3 id="_a_full_lifecycle_operator_to_reduce_deployment_and_management_overhead_in_openshift">A Full Lifecycle Operator to reduce deployment and management overhead in OpenShift</h3>
<div class="paragraph">
<p>An Operator enables the operations and lifecycle management for an application by using the underlying Kubernetes APIs. This means that complex applications e.g., consumed as services such as distributed caching, databases, etc. can easily get upgraded when newer versions arrive and more; also meaning no human intervention. The Operator SDK enables developers to write such Operators. Red Hat Data Grid 8.0 introduces a fully supported Data Grid Operator that provides operational intelligence.</p>
</div>
<div class="paragraph">
<p>With the latest release of Red Hat Data Grid, now you can also use it with an Operator.</p>
</div>
<div class="paragraph">
<p>Try some of the following documentation to create a Data Grid Operator subscription and get running in OpenShift:
Getting Started with Data Grid Operator
Running Data Grid for OpenShift</p>
</div>
</div>
<div class="sect2">
<h3 id="_a_new_server_architecture">A new server architecture</h3>
<div class="paragraph">
<p>Cloud and Container Native Data Grid needs to be a reduced footprint, and that’s what the latest version of Red Hat Data Grid brings. It reduces both the disk footprint and initial heap size upto 50%, leaving more memory for your data. You can now run the server without the Red Hat JBoss Enterprise Application Platform (EAP), ensuring a lower memory and disk footprint
also simplifies configuration.</p>
</div>
<div class="paragraph">
<p>Moreover, Data Grid 8.0 servers provide several enhancements and improvements to security, including integration with Red Hat SSO and a smaller attack surface.</p>
</div>
<div class="paragraph">
<p>See Getting Started with Data Grid Server and create a running Data Grid cluster in a few minutes.</p>
</div>
</div>
<div class="sect2">
<h3 id="_a_more_performant_and_rich_rest_api">A more performant and rich REST API</h3>
<div class="paragraph">
<p>Red Hat Data Grid 8.0 introduces REST API v2.
The API is with 50% faster response rates compared to v1. There are also new capabilities introduced such as
Now you can access data and manipulate objects such as counters.
Perform operations such as gracefully shutting down Data Grid clusters or transferring cache state to backup locations when using cross-site replication.
And lastly, Monitor cluster and server health and retrieve statistics.
Moreover, Red Hat Data Grid REST API v2 also automatically converts between storage formats such as JSON, XML, Protobuf, and plain text for increased interoperability. The Red Hat Data Grid engineering team develop and maintain comprehensive REST API Documentation</p>
</div>
</div>
<div class="sect2">
<h3 id="_a_powerful_cli">A powerful CLI</h3>
<div class="paragraph">
<p>In 8.0, Data Grid gives you a new CLI with intuitive commands for remotely accessing data and managing clusters.
The CLI uses familiar Bash commands for navigating, such as cd and ls. It also provides command history and auto-completion for ease of use.</p>
</div>
<div class="paragraph">
<p>Additionally, the CLI provides help text and man pages for commands with clear examples.</p>
</div>
<div class="paragraph">
<p>Try the docs: Getting Started with the Data Grid CLI.</p>
</div>
</div>
<div class="sect2">
<h3 id="_enhanced_observability">Enhanced observability</h3>
<div class="paragraph">
<p>Now you can use the /metrics endpoint for integration with Prometheus. Moreover, Red Hat Data Grid 8 is also compatible with Eclipse Microprofile Metrics API. More specific metrics and gauges are included. For more details, check the documentation here. Data Grid 8.0 also offers improved statistics and management operations via JMX and updates to logging with coarse-grained logging categories and support for logs in JSON format.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_is_caching_and_how_to_apply_it_with_red_hat_data_grid">What is Caching and how to apply it with Red Hat Data Grid?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Modern applications use data and lets assume lots of data, whether it comes from databases, files, webservices, rpc call etc.
When an application has to process this data, what is the most natural way of doing it? Mostly the application will process this data in memory.
Lets assume I have a very slow database, this could be due to any reason, network latency, or even big queries that return alot of data.
So the most straight forward way of handling this, would be to store some of that data in the memory. By doing so, you would be able to process requests to your systems mush faster. However there are challenges. How much data should you store in memory? and most importantly what will happen in case of failure scenarios?</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Will you loose all the state of your data in memory?</p>
</li>
<li>
<p>Will you need to re-read all your data and events inorder to get back to the same state where you failed. Or you might have to let go of that entirely.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Now the above two might seem very simple, but that tasks can be tideous and most importantly error prone.
So at this point we could introduce a local cache that e.g. could be a ConcurrentHashMap. and alot of us might have done this in the past. However as a developer you might know that this has not much effect in case of failures and the handling that you will need to do incase of failures.
So the need is entirely for a component that can not just cache data in the memory, but give</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A consistent way to handle data and state in the memory.</p>
</li>
<li>
<p>Resiliencey in case of failures.</p>
</li>
<li>
<p>Processing efficency and performance.</p>
</li>
<li>
<p>Events, streams, and distribution capabilites.</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/caching.png" alt="Caching" width="900">
</div>
</div>
<div class="paragraph">
<p>By having such capabilites a cache is no longer just a datastructure in the memory, but also as a developer now you have the possiblity to take this component out of your local in memory processing and distribute it out on the network. Thereby incase of application failures you will still be able to access this data from the last point where you left off.</p>
</div>
<div class="paragraph">
<p>Now getting back to our primary question, how much data should you store in memory? Partially we have already discussed this above. Whats important is that as a developer you should be able to specifiy TTL (Time To Live) for your cache and its entries. You should be able to define eviction and expiration. There by knowing when your cash is hot and what data resides in it. Most over you should be able to do this distributed, cluster wide or remotely.</p>
</div>
<div class="paragraph">
<p>Once a cache is remote, we also want some of the distributed features, e.g. monitoring.
Lets take a look at some of the caching strategies.</p>
</div>
<div class="sect3">
<h4 id="_local_cache">Local cache</h4>
<div class="paragraph">
<p>The primary use for Red Hat Data Grid is to provide a fast in-memory cache of frequently accessed data. Suppose you have a slow data source (database, web service, text file, etc): you could load some or all of that data in memory so that it’s just a memory access away from your code. Using Red Hat Data Grid is better than using a simple ConcurrentHashMap. By setting up an embedded cache, Red Hat Dat Grid also allows you to tap into more features e.g. expiration, eviction, events on the cache etc. All make out a much better way of handling your cache and component design. Moreover if you would want to cluster such a cache that is also easily possible.</p>
</div>
</div>
<div class="sect3">
<h4 id="_as_a_clustered_cache">As a clustered cache</h4>
<div class="paragraph">
<p>So lets assume you started with a local embedded cache in your application, and now you suddenly realize that one instance of your application is not enough to handle the load from your users or systems. What do you do? With Red Hat Data Grid you can now scale that cache into a cluster. You dont need to change how you use your cache, but adding a few additonal config params you can now have a clustered cache and there by having muliptle instances of your application listenting to the same coherent cache. Events will be fired accorss the clusters, your eviction and expiration will happen accorss the cluster.
And most over, you now even have the possiblity to distribute your keys accross the cluster. Red Hat Data Grid can scale horizontally to hundreds of nodes.</p>
</div>
</div>
<div class="sect3">
<h4 id="_as_a_remote_cache">As a remote cache</h4>
<div class="paragraph">
<p>Lets just say you used the clusterd cache, and embedded it in your application, which means that everytime a new instance of your application started you would have a new instance of your embedded cache ready to become part of the cluster. Now this is all great. But what if, you dont want that clustering in your application. rather then you might want to use a component outside of your applications lifecycle. Or you would want to share this cache accross multiple applications. In that case the Red Hat Data Grid could be used as a remote data grid. Now you can access your cache via multiple programming runtimes. e.g. Vert.x, Quarkus, NodeJS, C#, C/C++ etc. And your cache lifecycle will be independant of the applications life cycle, which is a great advantage in many cases.</p>
</div>
<div class="paragraph">
<p>Congratulations! By now you understand the different patterns of caching, and the requirements. Lets go ahead and create our first application and learn how we can use Red Hat Data Grid to achieve caching. Press next!</p>
</div>
</div>
<div class="sect2">
<h3 id="_additional_resources">Additional Resources:</h3>
<div class="ulist">
<ul>
<li>
<p>Traditional zip deployments are available on the <a href="https://access.redhat.com/" target="_blank" rel="noopener">Customer Portal</a>.</p>
</li>
<li>
<p>The container distribution and operator are available in the <a href="https://catalog.redhat.com/software/containers/explore" target="_blank" rel="noopener">Red Hat Container Catalog</a></p>
</li>
<li>
<p>Product documentation is available <a href="https://docs.redhat.com/" target="_blank" rel="noopener">here</a></p>
</li>
<li>
<p>Getting Started Guide that will get you running with RHDG 8 in 5 minutes.</p>
</li>
<li>
<p><a href="https://access.redhat.com/documentation/en-us/red_hat_data_grid/8.0/html/data_grid_migration_guide/index" target="_blank" rel="noopener">Migration Guide</a></p>
</li>
<li>
<p><a href="https://github.com/redhat-developer/redhat-datagrid-tutorials" target="_blank" rel="noopener">Starter Tutorials</a></p>
</li>
<li>
<p><a href="https://access.redhat.com/articles/4933371" target="_blank" rel="noopener">Supported Components</a></p>
</li>
<li>
<p><a href="https://access.redhat.com/articles/4933551" target="_blank" rel="noopener">Supported Configurations</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
        <hr>
        <h2>Getting started with Data Grid</h2>
        <div class="paragraph">
<p>Lets delve down into some of the basic features of a Red Hat Data Grid. Our workshop includes alot more indepth material going forward, but its important we set up a solid base with understanding more about Red Hat Data Grid and Infinispan. In this section we have a bunch of exercises that we will go through.</p>
</div>
<div class="sect2">
<h3 id="_about_your_workspace_environment_today">About your workspace environment today</h3>
<div class="paragraph">
<p>You will be using Red Hat CodeReady Workspaces, an online IDE based on <a href="https://www.eclipse.org/che/" target="_blank" rel="noopener">Eclipe Che</a>. <strong>Changes to files are auto-saved every few seconds</strong>, so you don’t need to explicitly save changes.</p>
</div>
<div class="paragraph">
<p>To get started, <a href="http://codeready-codeready.apps.cluster-cph-b051.cph-b051.example.opentlc.com/" target="_blank" rel="noopener">access the CodeReady Workspaces instance</a> and log in using the username and password you’ve been assigned (e.g. <code>user19/openshift</code>):</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/che-login.png" alt="cdw" width="700">
</div>
</div>
<div class="paragraph">
<p>Once you log in, you’ll be placed on your personal dashboard. Click on the name of the pre-created workspace on the left, as shown below (the name will be different depending on your assigned number). You can also click on the name of the workspace in the center, and then click on the green button that says <em>Open</em> on the top right hand side of the screen.</p>
</div>
<div class="paragraph">
<p>This IDE is based on Eclipse Che (which is in turn based on MicroSoft VS Code editor).</p>
</div>
<div class="paragraph">
<p>You can see icons on the left for navigating between project explorer, search, version control (e.g. Git), debugging, and other plugins.  You’ll use these during the course of this workshop. Feel free to click on them and see what they do:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/crw-icons.png" alt="cdw" width="400">
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If things get weird or your browser appears, you can simply reload the browser tab to refresh the view.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Many features of CodeReady Workspaces are accessed via <strong>Commands</strong>. You can see a few of the commands listed with links on the home page (e.g. <em>New File..</em>, <em>Git Clone..</em>, and others).</p>
</div>
<div class="paragraph">
<p>If you ever need to run commands that you don’t see in a menu, you can press kbd:[F1] to open the command window, or the more traditional kbd:[Control+SHIFT+P] (or kbd:[Command+SHIFT+P] on Mac OS X).</p>
</div>
<div class="paragraph">
<p>Let’s import our first project. Click on <strong>Git Clone..</strong> (or type kbd:[F1], enter 'git' and click on the auto-completed <em>Git Clone..</em> )</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/gitclonepage.png" alt="cdw" width="600">
</div>
</div>
<div class="paragraph">
<p>Step through the prompts, using the following value for <strong>Repository URL</strong>:</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">https://github.com/RedHat-Middleware-Workshops/dg8-workshop</code></pre>
</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/gitcloneembedded.png" alt="crw" width="600">
</div>
</div>
<div class="paragraph">
<p>Next, select <code>$CHE_PROJECTS_ROOT</code> in the drop-down menu for destination directory:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/projectplace.png" alt="crw" width="600">
</div>
</div>
<div class="paragraph">
<p>And click <strong>Select Repository Location</strong>.</p>
</div>
<div class="paragraph">
<p>Once imported, choose <strong>Add to workspace</strong> when prompted.</p>
</div>
<div class="paragraph">
<p>The project should now be imported into your workspace and as an example screenshot as below you should be able to see your project as well.<code>dg8-embedded-quarkus</code></p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/workspaceview.png" alt="crw" width="800">
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The Terminal window in CodeReady Workspaces. You can open a terminal window for any of the containers running in your Developer workspace. For the rest of these labs, anytime you need to run a command in a terminal, you can use the <strong>&gt;_ New Terminal</strong> command on the right:</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/codeready-workspace-terminal.png" alt="codeready-workspace-terminal" width="600">
</div>
</div>
<div class="paragraph">
<p>We will be doing the exercises in this section and for that we have a project called <code>dg8-exercises</code>, Open each exercise file e.g. Exercise1.java is for Exercise 1. There are a total of 6 exercises and we will walk through the different concepts.</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Also important, in case you run one of your Exercise1 Commands, and compilation fails. You would want to run it at some point with the corrections. Just click the command again from the MyWorkspace menu and you will see the following dialog box, Click <code>Restart Task</code>.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/reruntask.png" alt="codeready-workspace-rerun">
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Where you see the // TODO Comment in the code snippets, you will see the same in the Exercise java files. Your task is to write that code in the Exercise java file under the right //TODO</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Make sure that you uncomment the code before you start your exercise; the uncomment marks are should be marked as follows</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>UNCOMMENT When starting this exercise</strong></p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_exercise_1_creating_a_local_cache">Exercise 1: Creating a local Cache</h3>
<div class="paragraph">
<p>First a bit about Maps. Why Maps are good for Cache? Maps are fast, they use methods like hashcode() and equals to determine how to add data to the map. Which also means they can be fast enough to O(1) time to read and write the data. That is excpetional performance, and thats exactly what you want from a cache. Data storage is in Key and Value pairs. So you have a key which is unique to your value. There is a lot more to Maps, but lets start with a basic Cahce how-to.</p>
</div>
<div class="paragraph">
<p>A CacheManager is the primary mechanism for retrieving a Cache instance, and is often used as a starting point to using the Cache.
Essentially if you were using a Map object you would just create a Map and store all your K,V in it. However when you use a tool like Red Hat Data Grid/Inifinispan you get more then just a simple map e.g. Listeners, events etc. all of which we will talk about in further sections.</p>
</div>
<div class="paragraph">
<p>CacheManagers are heavyweight objects, and its not recommended to have more than one CacheManager being used per JVM (unless specific configuration requirements require more than one; but either way, this would be a minimal and finite number of instances).</p>
</div>
<div class="paragraph">
<p>Add the following to your main method in class Exercise1</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="comment">// TODO: Construct a simple local cache manager with default configuration</span>
    DefaultCacheManager cacheManager = <span class="keyword">new</span> DefaultCacheManager();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that we have cacheManager, we can now define what a Cache should look like. We could choose many features from the system, e.g. if we were adding grouping, streams, listeners, strategies for eviction or clustering etc, we would do that here. The following example just takes the default configuration</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="comment">// TODO: Define local cache configuration</span>
    cacheManager.defineConfiguration(<span class="string"><span class="delimiter">"</span><span class="content">local</span><span class="delimiter">"</span></span>, <span class="keyword">new</span> ConfigurationBuilder().build());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Perfect so now we have defined our Cache, time for us to get that cache from our CacheManager. We have also defined that our Cache will have both our Key and Value as Strings.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="comment">// TODO: Obtain the local cache</span>
    Cache&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; cache = cacheManager.getCache(<span class="string"><span class="delimiter">"</span><span class="content">local</span><span class="delimiter">"</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally lets put the value in the Cache. Change the "Key" and "Value" to e.g. name and yourname or feel free to use something else.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="comment">// TODO: Store a value</span>
    cache.put(<span class="string"><span class="delimiter">"</span><span class="content">key</span><span class="delimiter">"</span></span>, <span class="string"><span class="delimiter">"</span><span class="content">value</span><span class="delimiter">"</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we will get the value by specifying the key. here the key will be the same as we used in our previous line <code>cache.put</code>; By specifying a key to the Cache, you can get the value stored in it; the same process is also use for an update.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="comment">// TODO: Retrieve the value and print it out</span>
    <span class="predefined-type">System</span>.out.printf(<span class="string"><span class="delimiter">"</span><span class="content">key = %s</span><span class="char">\n</span><span class="delimiter">"</span></span>, cache.get(<span class="string"><span class="delimiter">"</span><span class="content">key</span><span class="delimiter">"</span></span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally CacheManager is a heavy object, it does alot, so no need to keep it going on. When done, we close that instance by calling the <code>stop()</code> method.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="comment">// TODO: Stop the cache manager and release all resources</span>
    cacheManager.stop();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Great so, now we have typed all our code. lets try to run this example.</p>
</div>
<div class="paragraph">
<p>Open a terminal in your CodeReady Workspace, you can do this by using the menu on the right hand called MyWorkspace. Click on <code>New Terminal</code> and a terminal should open in your browser. You can also choose to execute the command <code>Exercise1</code> in your MyWorkspace Menu on the right</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">    mvn clean compile
    mvn exec:java -Dexec.mainClass=org.acme.Exercise1</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should be able to see an output similar to the following.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">[INFO] --- exec-maven-plugin:1.6.0:java (default-cli) @ dg8-exercises ---
Apr 13, 2020 5:34:46 PM org.infinispan.factories.GlobalComponentRegistry preStart
INFO: ISPN000128: Infinispan version: Red Hat Data Grid 'Turia' 10.1.5.Final-redhat-00001
Apr 13, 2020 5:34:46 PM org.infinispan.lock.impl.ClusteredLockModuleLifecycle cacheManagerStarted
INFO: ISPN029009: Configuration is not clustered, clustered locks are disabled
key = value</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exercise_2_jsr_107_jcache">Exercise 2: JSR-107 JCache</h3>
<div class="paragraph">
<p>The term Cache is generally reffered to a component that stored data in memory so that its easy to read the value that might be hard to calculate or that need to be accessed rather quickly. As discussed earlier, simple java.util packages do now have all the capabilities required and wiring them by oneself is complex if not hard enough. The Java Specification Request (JSR-107) has been created to defind temporary caching API for Java. The specification defines some Standard APIs for storing and managing data both for local and distributed usecases.</p>
</div>
<div class="paragraph">
<p>Lets take a look at how you can use JSR-107 with Red Hat Data Grid/Infinispan</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        <span class="comment">// TODO: Construct a simple local cache manager with default configuration</span>
        CachingProvider jcacheProvider = Caching.getCachingProvider();
        CacheManager cacheManager = jcacheProvider.getCacheManager();
        MutableConfiguration&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; configuration = <span class="keyword">new</span> MutableConfiguration&lt;&gt;();
        configuration.setTypes(<span class="predefined-type">String</span>.class, <span class="predefined-type">String</span>.class);

        <span class="comment">// TODO: create a cache using the supplied configuration</span>
        Cache&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; cache = cacheManager.createCache(<span class="string"><span class="delimiter">"</span><span class="content">myCache</span><span class="delimiter">"</span></span>, configuration);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lets take a more indepth look at the code above
&lt;1&gt; We use a CachingProvider which is part of the standards API.
&lt;2&gt; The Caching provider inturn gives us a cacheManager.
&lt;3&gt; We create a configuration object for our Cache. A MutlableConfiguration
&lt;4&gt; and here we also set the Type of our Cache, if you remember this is different from our previous exercise, since we are using the JSR-107 API now.
&lt;5&gt; and finally we get our cache</p>
</div>
<div class="paragraph">
<p>Finally lets put the value in the Cache. Change the "Key" and "Value" to e.g. name and yourname or feel free to use something else.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        <span class="comment">// Store and retrieve value</span>
        cache.put(<span class="string"><span class="delimiter">"</span><span class="content">key</span><span class="delimiter">"</span></span>, <span class="string"><span class="delimiter">"</span><span class="content">value</span><span class="delimiter">"</span></span>);
        <span class="predefined-type">System</span>.out.printf(<span class="string"><span class="delimiter">"</span><span class="content">key = %s</span><span class="char">\n</span><span class="delimiter">"</span></span>, cache.get(<span class="string"><span class="delimiter">"</span><span class="content">key</span><span class="delimiter">"</span></span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>And then lets close our CacheManager.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        <span class="comment">// TODO: Stop the cache manager and release all resources</span>
        cacheManager.close();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run the above exercise as follows in the CodeReady terminal or you can also choose to execute the command <code>Exercise2</code> in your MyWorkspace Menu on the right.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">    mvn clean compile
    mvn exec:java -Dexec.mainClass=org.acme.Exercise2</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should be able to see an output similar to the following. On the last line you can see your key, value printed.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">[INFO] --- exec-maven-plugin:1.6.0:java (default-cli) @ dg8-exercises ---
Apr 13, 2020 6:17:56 PM org.infinispan.factories.GlobalComponentRegistry preStart
INFO: ISPN000128: Infinispan version: Red Hat Data Grid 'Turia' 10.1.5.Final-redhat-00001
Apr 13, 2020 6:17:56 PM org.infinispan.lock.impl.ClusteredLockModuleLifecycle cacheManagerStarted
INFO: ISPN029009: Configuration is not clustered, clustered locks are disabled
key = value</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exercise_3_functional_api">Exercise 3: Functional API</h3>
<div class="paragraph">
<p>The approach taken by the Functional Map API when working with multiple keys is to provide a lazy, pull-style API. All multi-key operations take a collection parameter which indicates the keys to work with (and sometimes contain value information too), and a function to execute for each key/value pair. Each function’s ability depends on the entry view received as function parameter, which changes depending on the underlying map: ReadEntryView for ReadOnlyMap, WriteEntryView for WriteOnlyMap, or ReadWriteView for ReadWriteMap. The return type for all multi-key operations, except the ones from WriteOnlyMap, return an instance of Traversable which exposes methods for working with the returned data from each function execution. Let’s see an example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This example demonstrates some of the key aspects of working with multiple entries using the Functional Map API:</p>
</li>
<li>
<p>As explained in the previous blog post, all data-handling methods (including multi-key methods) for WriteOnlyMap return CompletableFuture&lt;Void&gt;, because there’s nothing the function can provide that could not be computed in advance or outside the function.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Normally, the order of the Traversable matches the order of the input collection though this is not currently guaranteed.</p>
</div>
<div class="paragraph">
<p>There is a special type of multi-key operations which work on all keys/entries stored in Infinispan. The behaviour is very similar to the multi-key operations shown above, with the exception that they do not take a collection of keys (and/or values) as parameters:</p>
</div>
<div class="paragraph">
<p>There’s a few interesting things to note about working with all entries using the Functional Map API:
- When working with all entries, the order of the Traversable is not guaranteed.
- Read-only’s keys() and entries() offer the possibility to traverse all keys and entries present in the cache. When traversing entries, both keys and values including metadata are available. Contrary to Java’s ConcurrentMap, there’s no possibility to navigate only the values (and metadata) since there’s little to be gained from such method and once a key’s entry has been retrieved, there’s no extra cost to provide the key as well.</p>
</div>
<div class="paragraph">
<p>Lets start by initializing our Cache with the DefaultCacheManager as we have done so in the previous labs. However we will use the functional API and hence after getting the Cache our Map implementation will be different. How to use the Functional API?
Using an asynchronous API, all methods that return a single result, return a CompletableFuture which wraps the result. To avoid blocking, it offers the possibility to receive callbacks when the CompletableFuture has completed, or it can be chained or composes with other CompletableFuture instances.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        DefaultCacheManager cacheManager = <span class="keyword">new</span> DefaultCacheManager();
        cacheManager.defineConfiguration(<span class="string"><span class="delimiter">"</span><span class="content">local</span><span class="delimiter">"</span></span>, <span class="keyword">new</span> ConfigurationBuilder().build());
        AdvancedCache&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; cache = cacheManager.&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt;getCache(<span class="string"><span class="delimiter">"</span><span class="content">local</span><span class="delimiter">"</span></span>).getAdvancedCache();
        FunctionalMapImpl&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; functionalMap = FunctionalMapImpl.create(cache);
        FunctionalMap.WriteOnlyMap&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; writeOnlyMap = WriteOnlyMapImpl.create(functionalMap);<i class="conum" data-value="1"></i><b>(1)</b>
        FunctionalMap.ReadOnlyMap&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; readOnlyMap = ReadOnlyMapImpl.create(functionalMap);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next what you would want to do is asynchronously write to this Cache.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        <span class="comment">// TODO Execute two parallel write-only operation to store key/value pairs</span>
        CompletableFuture&lt;<span class="predefined-type">Void</span>&gt; writeFuture1 = writeOnlyMap.eval(<span class="string"><span class="delimiter">"</span><span class="content">key1</span><span class="delimiter">"</span></span>, <span class="string"><span class="delimiter">"</span><span class="content">value1</span><span class="delimiter">"</span></span>,
                (v, writeView) -&gt; writeView.set(v)); <i class="conum" data-value="1"></i><b>(1)</b>
        CompletableFuture&lt;<span class="predefined-type">Void</span>&gt; writeFuture2 = writeOnlyMap.eval(<span class="string"><span class="delimiter">"</span><span class="content">key2</span><span class="delimiter">"</span></span>, <span class="string"><span class="delimiter">"</span><span class="content">value2</span><span class="delimiter">"</span></span>,
                (v, writeView) -&gt; writeView.set(v));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Write-only operations require locks to be acquired but crucially they do not require reading previous value or metadata parameter information associated with the cached entry, which sometimes can be expensive since they involve talking to a remote node in the cluster or the persistence layer So, exposing write-only operations makes it easy to take advantage of this important optimisation.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>And now lets do a read operation in similar</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        <span class="comment">//TODO When each write-only operation completes, execute a read-only operation to retrieve the value</span>
        CompletableFuture&lt;<span class="predefined-type">String</span>&gt; readFuture1 =
                writeFuture1.thenCompose(r -&gt; readOnlyMap.eval(<span class="string"><span class="delimiter">"</span><span class="content">key1</span><span class="delimiter">"</span></span>, EntryView.ReadEntryView::get)); <i class="conum" data-value="1"></i><b>(1)</b>
        CompletableFuture&lt;<span class="predefined-type">String</span>&gt; readFuture2 =
                writeFuture2.thenCompose(r -&gt; readOnlyMap.eval(<span class="string"><span class="delimiter">"</span><span class="content">key2</span><span class="delimiter">"</span></span>, EntryView.ReadEntryView::get));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Exposes read-only operations that can be executed against the functional map. The information that can be read per entry in the functional map. Read-only operations have the advantage that no locks are acquired for the duration of the operation.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Finally lets print the operation as it completes.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        <span class="comment">//TODO When the read-only operation completes, print it out</span>
        <span class="predefined-type">System</span>.out.printf(<span class="string"><span class="delimiter">"</span><span class="content">Created entries: %n</span><span class="delimiter">"</span></span>);
        CompletableFuture&lt;<span class="predefined-type">Void</span>&gt; end = readFuture1.thenAcceptBoth(readFuture2, (v1, v2) -&gt;
                <span class="predefined-type">System</span>.out.printf(<span class="string"><span class="delimiter">"</span><span class="content">key1 = %s%nkey2 = %s%n</span><span class="delimiter">"</span></span>, v1, v2));

        <span class="comment">// Wait for this read/write combination to finish</span>
        end.get();</code></pre>
</div>
</div>
<div class="paragraph">
<p>So we have seen how a WriteOnly and ReadOnly Map works, lets also add the ReadWriteMap
Read-write operations offer the possibility of writing values or metadata parameters, and returning previously stored information. Read-write operations are also crucial for implementing conditional, compare-and-swap (CAS) like operations. Locks are acquired before executing the read-write lambda.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        <span class="comment">//TODO Create a read-write map</span>
        FunctionalMap.ReadWriteMap&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; readWriteMap = ReadWriteMapImpl.create(functionalMap);

        <span class="comment">// Use read-write multi-key based operation to write new values</span>
        <span class="comment">// together with lifespan and return previous values</span>
        <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; data = <span class="keyword">new</span> <span class="predefined-type">HashMap</span>&lt;&gt;();
        data.put(<span class="string"><span class="delimiter">"</span><span class="content">key1</span><span class="delimiter">"</span></span>, <span class="string"><span class="delimiter">"</span><span class="content">newValue1</span><span class="delimiter">"</span></span>);
        data.put(<span class="string"><span class="delimiter">"</span><span class="content">key2</span><span class="delimiter">"</span></span>, <span class="string"><span class="delimiter">"</span><span class="content">newValue2</span><span class="delimiter">"</span></span>);
        Traversable&lt;<span class="predefined-type">String</span>&gt; previousValues = readWriteMap.evalMany(data, (v, readWriteView) -&gt; {
            <span class="predefined-type">String</span> prev = readWriteView.find().orElse(<span class="predefined-constant">null</span>);
            readWriteView.set(v, <span class="keyword">new</span> MetaLifespan(<span class="predefined-type">Duration</span>.ofHours(<span class="integer">1</span>).toMillis()));
            <span class="keyword">return</span> prev;
        });</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now lets run our code and see how it works</p>
</div>
<div class="paragraph">
<p>Run the above exercise as follows in the CodeReady terminal or you can also choose to execute the command <code>Exercise3</code> in your MyWorkspace Menu on the right</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">    mvn clean compile
    mvn exec:java -Dexec.mainClass=org.acme.Exercise3</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should be able to see an output similar to the following. On the last line you can see your key, value printed.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">INFO: ISPN000128: Infinispan version: Red Hat Data Grid 'Turia' 10.1.5.Final-redhat-00001
Apr 13, 2020 9:24:12 PM org.infinispan.lock.impl.ClusteredLockModuleLifecycle cacheManagerStarted
INFO: ISPN029009: Configuration is not clustered, clustered locks are disabled
Created entries:
key1 = value1
key2 = value2
Updated entries:
ReadOnlySnapshotView{key=key1, value=newValue1, metadata=MetaParamsInternalMetadata{params=MetaParams{length=1, metas=[MetaLifespan=3600000]}}}
ReadOnlySnapshotView{key=key2, value=newValue2, metadata=MetaParamsInternalMetadata{params=MetaParams{length=1, metas=[MetaLifespan=3600000]}}}
Previous entry values:
value1
value2</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exercise_4_streaming_data_from_the_cache">Exercise 4: Streaming data from the Cache</h3>
<div class="paragraph">
<p>With Red Hat Data Grid/Infinispan you can use the Java Streams API and calculate analytics on exisiting data. Infinispan offers a simple way of passing lamdbas that do not need explicit casting and are Serializable. The ability to execute these streams in a distributed fashion they are serialized in a binary format.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Infinispan Distributed Java Streams can be used to calculate analytics over existing data. Through overloading of methods, Infinispan is able to offer a simple way of passing lambdas that are made to be Serializable without the need of explicit casting. Being able to produce binary formats for the lambdas is an important step for java streams executions to be distributed.</pre>
</div>
</div>
<div class="paragraph">
<p>With the following we create a lambda to write data into our cache</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        <span class="comment">// TODO: Store some values</span>
        <span class="type">int</span> range = <span class="integer">10</span>;
        IntStream.range(<span class="integer">0</span>, range).boxed().forEach(i -&gt; cache.put(i + <span class="string"><span class="delimiter">"</span><span class="content">-key</span><span class="delimiter">"</span></span>, i + <span class="string"><span class="delimiter">"</span><span class="content">-value</span><span class="delimiter">"</span></span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>And now we read that data summing up the values.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        <span class="comment">// TODO: Map and reduce the keys</span>
        <span class="type">int</span> result = cache.keySet().stream()
                .map(e -&gt; <span class="predefined-type">Integer</span>.valueOf(e.substring(<span class="integer">0</span>, e.indexOf(<span class="string"><span class="delimiter">"</span><span class="content">-</span><span class="delimiter">"</span></span>))))
                .collect(() -&gt; Collectors.summingInt(i -&gt; i.intValue()));
        <span class="predefined-type">System</span>.out.printf(<span class="string"><span class="delimiter">"</span><span class="content">Result = %d</span><span class="char">\n</span><span class="delimiter">"</span></span>, result);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now lets run our code and see how it works</p>
</div>
<div class="paragraph">
<p>Run the above exercise as follows in the CodeReady terminal or you can also choose to execute the command <code>Exercise4</code> in your MyWorkspace Menu on the right</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">    mvn clean compile
    mvn exec:java -Dexec.mainClass=org.acme.Exercise4</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should be able to see an output similar to the following. On the last line you can see your key, value printed.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">Apr 13, 2020 9:32:53 PM org.infinispan.factories.GlobalComponentRegistry preStart
INFO: ISPN000128: Infinispan version: Red Hat Data Grid 'Turia' 10.1.5.Final-redhat-00001
Apr 13, 2020 9:32:53 PM org.infinispan.lock.impl.ClusteredLockModuleLifecycle cacheManagerStarted
INFO: ISPN029009: Configuration is not clustered, clustered locks are disabled
Result = 45</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exercise_5_using_transactions">Exercise 5: Using Transactions</h3>
<div class="paragraph">
<p>Transactions are important in any business application. Usually transaction is used with dataset, and quite often related to a database, but thats not exactly true, if you have a distributed dataset, you will need transations for your business logic to prevail. Infinspan provides transations. You might have a scenario where the cluster adds a node, or where an entry has been written on another node. The infinispan transaction manager is aware of such events and handles them. You can read more about the design of transactions here: <a href="https://github.com/infinispan/infinispan-designs" class="bare">https://github.com/infinispan/infinispan-designs</a></p>
</div>
<div class="paragraph">
<p>Lets get the TransactionManager from the cache</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="comment">//TODO Obtain the transaction manager</span>
    TransactionManager transactionManager = cache.getAdvancedCache().getTransactionManager();</code></pre>
</div>
</div>
<div class="paragraph">
<p>We begin our transaction , write two entries and then close it.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        <span class="comment">// TODO Perform some operations within a transaction and commit it</span>
        transactionManager.begin();
        cache.put(<span class="string"><span class="delimiter">"</span><span class="content">key1</span><span class="delimiter">"</span></span>, <span class="string"><span class="delimiter">"</span><span class="content">value1</span><span class="delimiter">"</span></span>);
        cache.put(<span class="string"><span class="delimiter">"</span><span class="content">key2</span><span class="delimiter">"</span></span>, <span class="string"><span class="delimiter">"</span><span class="content">value2</span><span class="delimiter">"</span></span>);
        transactionManager.commit();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lets also do a rollback scenario. So we write to entries and rollback</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        <span class="comment">//TODO Perform some operations within a transaction and roll it back</span>
        transactionManager.begin();
        cache.put(<span class="string"><span class="delimiter">"</span><span class="content">key1</span><span class="delimiter">"</span></span>, <span class="string"><span class="delimiter">"</span><span class="content">value3</span><span class="delimiter">"</span></span>);
        cache.put(<span class="string"><span class="delimiter">"</span><span class="content">key2</span><span class="delimiter">"</span></span>, <span class="string"><span class="delimiter">"</span><span class="content">value4</span><span class="delimiter">"</span></span>);
        transactionManager.rollback();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now lets run our code and see how it works</p>
</div>
<div class="paragraph">
<p>Run the above exercise as follows in the CodeReady terminal or you can also choose to execute the command <code>Exercise5</code> in your MyWorkspace Menu on the right</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">    mvn clean compile
    mvn exec:java -Dexec.mainClass=org.acme.Exercise5</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should be able to see an output similar to the following. On the last line you can see your key, value printed.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">INFO: ISPN000128: Infinispan version: Red Hat Data Grid 'Turia' 10.1.5.Final-redhat-00001
Apr 13, 2020 9:40:50 PM org.infinispan.lock.impl.ClusteredLockModuleLifecycle cacheManagerStarted
INFO: ISPN029009: Configuration is not clustered, clustered locks are disabled
Apr 13, 2020 9:40:50 PM org.infinispan.transaction.lookup.GenericTransactionManagerLookup useDummyTM
INFO: ISPN000104: Using EmbeddedTransactionManager
key1 = value1
key2 = value2
key1 = value1
key2 = value2</code></pre>
</div>
</div>
<div class="paragraph">
<p>So as you can see even though we wrote the new values, but by rolling back, they do not exist anymore. This is an awesome feature to have Transactions over the cache.</p>
</div>
</div>
<div class="sect2">
<h3 id="_exercise_6_queries_to_the_cache_with_lucene">Exercise 6: Queries to the Cache with Lucene</h3>
<div class="paragraph">
<p>Infinispan includes a highly scalable distributed Apache Lucene Directory implementation.</p>
</div>
<div class="paragraph">
<p>This directory closely mimics the same semantics of the traditional filesystem and RAM-based directories, being able to work as a drop-in replacement for existing applications using Lucene and providing reliable index sharing and other features of Infinispan like node auto-discovery, automatic failover and rebalancing, optionally transactions, and can be backed by traditional storage solutions as filesystem, databases or cloud store engines.</p>
</div>
<div class="paragraph">
<p>The implementation extends Lucene’s org.apache.lucene.store.Directory so it can be used to store the index in a cluster-wide shared memory, making it easy to distribute the index. Compared to rsync-based replication this solution is suited for use cases in which your application makes frequent changes to the index and you need them to be quickly distributed to all nodes. Consistency levels, synchronicity and guarantees, total elasticity and auto-discovery are all configurable; also changes applied to the index can optionally participate in a JTA transaction, optionally supporting XA transactions with recovery.</p>
</div>
<div class="paragraph">
<p>Since Lucene is part of infinispan, We need to make sure that we have the right configuration for it.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        <span class="comment">// Create cache config</span>
        ConfigurationBuilder builder = <span class="keyword">new</span> ConfigurationBuilder();
        builder.indexing().index(Index.ALL) <i class="conum" data-value="1"></i><b>(1)</b>
                .addProperty(<span class="string"><span class="delimiter">"</span><span class="content">default.directory_provider</span><span class="delimiter">"</span></span>, <span class="string"><span class="delimiter">"</span><span class="content">ram</span><span class="delimiter">"</span></span>) <i class="conum" data-value="2"></i><b>(2)</b>
                .addProperty(<span class="string"><span class="delimiter">"</span><span class="content">lucene_version</span><span class="delimiter">"</span></span>, <span class="string"><span class="delimiter">"</span><span class="content">LUCENE_CURRENT</span><span class="delimiter">"</span></span>); <i class="conum" data-value="3"></i><b>(3)</b>

        <span class="comment">// Obtain the cache</span>
        Cache&lt;<span class="predefined-type">String</span>, Person&gt; cache = cacheManager.administration()
                .withFlags(CacheContainerAdmin.AdminFlag.VOLATILE)
                .getOrCreateCache(<span class="string"><span class="delimiter">"</span><span class="content">cache</span><span class="delimiter">"</span></span>, builder.build());</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Here we are telling our Cache config that we want to index all entries</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The storage for lucene will in the memory</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>and we want to give it a version</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Now lets add a bit of more code to the above example.
In the following code we get the QueryFactory and create a query.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        <span class="comment">// TODO: Obtain a query factory for the cache</span>
        QueryFactory queryFactory = Search.getQueryFactory(cache);
        <span class="comment">// Construct a query</span>
        <span class="predefined-type">Query</span> query = queryFactory.from(Person.class).having(<span class="string"><span class="delimiter">"</span><span class="content">name</span><span class="delimiter">"</span></span>).eq(<span class="string"><span class="delimiter">"</span><span class="content">William</span><span class="delimiter">"</span></span>).toBuilder().build();
        <span class="comment">// Execute the query</span>
        <span class="predefined-type">List</span>&lt;Person&gt; matches = query.list();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now lets run our code and see how it works</p>
</div>
<div class="paragraph">
<p>Run the above exercise as follows in the CodeReady terminal or you can also choose to execute the command <code>Exercise6</code> in your MyWorkspace Menu on the right</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">    mvn clean compile
    mvn exec:java -Dexec.mainClass=org.acme.Exercise6</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should be able to see an output similar to the following. On the last line you can see your key, value printed.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">INFO: HSEARCH000034: Hibernate Search 5.10.7.Final-redhat-00001
Apr 13, 2020 9:57:45 PM org.hibernate.annotations.common.reflection.java.JavaReflectionManager &lt;clinit&gt;
INFO: HCANN000001: Hibernate Commons Annotations {5.0.5.Final}
Apr 13, 2020 9:57:45 PM org.infinispan.query.impl.LifecycleManager createQueryInterceptorIfNeeded
INFO: ISPN014003: Registering Query interceptor for cache cache
Match: Person [name=William, surname=Wordsworth]Match: Person [name=William, surname=Shakespeare][</code></pre>
</div>
</div>
<div class="paragraph">
<p>Its quite simple to add lucene based search to your Cache. Try to change the parameters a bit and experience this more.</p>
</div>
<div class="paragraph">
<p><strong>*Congratulations!!</strong> you have completed the first introductory exercises to Red Hat Data Grid 8.0. Lets move on to the next section and experience more indepth examples.</p>
</div>
</div>
        <hr>
        <h2>Caching 101, Lets get started with your first app</h2>
        <div class="paragraph">
<p>What could be cases where you want to use Cache; Lets take a moment and think about it. Where do you think you could use cache?
Well there could be limitless answers to this question; Some common usecases are listed below</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Lookup Data; if you have an app, that needs some user profile data etc, thats unecessary to pole everytime, and it doesnt change much</p>
</li>
<li>
<p>Latency or bulk; you might have a service or database that takes alot of time to load some of the data.</p>
</li>
<li>
<p>Traffic; you might have loads of users and trends are spiking</p>
</li>
<li>
<p>Session Storage; Storing your webapp sessions, this could be carts etc, that you can use to scale your application</p>
</li>
<li>
<p>Global Counters; You might want to create distributed keys accross a distributed dataset. Use this to update and fetch data.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/embeddedcache.png" alt="Caching" width="900">
</div>
</div>
<div class="paragraph">
<p>The above figure depicts a common scenario when you dont want to use a networked dataset that could be slow and with high latency, but rather use an inmemory cache. In this case the in-memory cache becomes the front for the data.</p>
</div>
<div class="paragraph">
<p>This lab is about an embedded or local cache, also a common usecase for applications.  What is an Embedded Cache in Red Hat Data Grid?</p>
</div>
<div class="sect2">
<h3 id="_embedded_cache_some_basics">Embedded Cache, Some basics</h3>
<div class="paragraph">
<p>The CacheManager is Red Hat Data Grid’s main entry point. You can use a CacheManager to</p>
</div>
<div class="ulist">
<ul>
<li>
<p>configure and obtain caches</p>
</li>
<li>
<p>manage and monitor your nodes</p>
</li>
<li>
<p>execute code across a cluster</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Depending on whether you are embedding Red Hat Data Grid in your application or you are using it remotely, you will be dealing with either an EmbeddedCacheManager or a RemoteCacheManager. While they share some methods and properties, be aware that there are semantic differences between them.</p>
</div>
<div class="paragraph">
<p>CacheManagers are heavyweight objects, and recommended use would be one CacheManager used per JVM (unless specific setups require more than one; but either way, this should be a minimal and finite number of instances).</p>
</div>
<div class="paragraph">
<p>The simplest way to create a CacheManager is:</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">EmbeddedCacheManager manager = <span class="keyword">new</span> DefaultCacheManager();</code></pre>
</div>
</div>
<div class="paragraph">
<p>which starts the most basic, local mode, non-clustered cache manager with no caches. CacheManagers have a lifecycle and the default constructors also call start(). Overloaded versions of the constructors are available, that do not start the CacheManager, although keep in mind that CacheManagers need to be started before they can be used to create Cache instances.</p>
</div>
<div class="paragraph">
<p>Once constructed, CacheManagers should be made available to any component that require to interact with it via some form of application-wide scope such as JNDI, a ServletContext or via some other mechanism such as an IoC container.</p>
</div>
<div class="paragraph">
<p>When you are done with a CacheManager, you must stop it so that it can release its resources:</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">manager.stop();</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will ensure all caches within its scope are properly stopped, thread pools are shutdown. If the CacheManager was clustered it will also leave the cluster gracefully.</p>
</div>
</div>
<div class="sect1">
<h2 id="_your_first_service_with_caching">Your first service with Caching</h2>
<div class="sectionbody">
<div class="paragraph">
<p>One of the common usecases for a Cache is to keep most used data in memory. Example having a Scoreboard in the cache. Lets assume theres a webpage that keeps the Score card for a round played by players on different tours. Now since this website expects people coming to check the top scores for example, or maybe based on a country etc. The best approach would be store this information in a cache rather then polling that information from different webservices or different databases as an example.</p>
</div>
<div class="paragraph">
<p>In our first service we will do exactly that. We will store this data in our Embedded Cache and understand not only how this works but the different ways of handling cache, getting events from it etc.</p>
</div>
<div class="sect2">
<h3 id="_project_details">Project details</h3>
<div class="paragraph">
<p>You can choose multiple runtimes to impelement this service, in our case today the example we have taken is with Quarkus. Quarkus is a Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM, crafted from the best of breed Java libraries and standards. Quarkus is also known for some of its cool features e.g Live Coding which we will also use in our labs. It makes it easier to code and see our changes as we do that.</p>
</div>
<div class="paragraph">
<p>Navigate to the project <code>dg8-embedded-quarkus</code>
This is a template project, and you will be writing code into this project.
As you can see there is already some files inplace. Lets take a look into what these files are and do.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_maven_dependencies">The Maven dependencies</h3>
<div class="paragraph">
<p>Open the pom.xml file in the project.</p>
</div>
<div class="paragraph">
<p>We will be using the following dependencies to create our service</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="maven">    &lt;dependency&gt;
      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
      &lt;artifactId&gt;quarkus-resteasy&lt;/artifactId&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
      &lt;artifactId&gt;quarkus-resteasy-jsonb&lt;/artifactId&gt; <i class="conum" data-value="2"></i><b>(2)</b>
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
      &lt;artifactId&gt;quarkus-infinispan-embedded&lt;/artifactId&gt; <i class="conum" data-value="3"></i><b>(3)</b>
    &lt;/dependency&gt;
    &lt;dependency&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Quarkus-resteasy; for our REST endpoint</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Quarkus-resteasy-jsonb; we will use this for Json serialization for our REST endpoint</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Quarkus-infinispan-embedded; This extension will enable us to embed our cache in our service.</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_the_score_entity">The Score Entity</h3>
<div class="paragraph">
<p>We have also created a POJO called Score, which will serve as our datastructure for the ScoreCard. If you have played golf, you might wonder this is a very basic data structure and that’s entirely true, we could have gone in more details but we have kept this short to cover all the features. And you are welcome to extending this datastructure after successfully finishing these labs.</p>
</div>
<div class="paragraph">
<p>If you open <code>Score.java</code> you will see the following first few lines</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="comment">// The number of holes played per round</span>
    <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> <span class="type">int</span> HOLES = <span class="integer">18</span>;

    <span class="comment">// The players is on this hole</span>
    <span class="directive">private</span> <span class="type">int</span> currentHole = <span class="integer">0</span>;

    <span class="comment">// Name of the player</span>
    <span class="directive">private</span> <span class="predefined-type">String</span> playerName;

    <span class="comment">// players unique Id</span>
    <span class="directive">private</span> <span class="predefined-type">String</span> playerId;

    <span class="comment">// The actual scoreCard</span>
    <span class="directive">private</span> <span class="type">int</span><span class="type">[]</span> card = <span class="keyword">new</span> <span class="type">int</span>[HOLES];

    <span class="comment">// The course player is playing on.</span>
    <span class="directive">private</span> <span class="predefined-type">String</span> course = <span class="string"><span class="delimiter">"</span><span class="content">St.Andrews Links</span><span class="delimiter">"</span></span>;

    <span class="comment">// the courseCard; the expected handicap</span>
    <span class="directive">private</span> <span class="type">int</span><span class="type">[]</span> courseCard = {<span class="integer">4</span>,<span class="integer">4</span>,<span class="integer">4</span>,<span class="integer">4</span>,<span class="integer">5</span>,<span class="integer">4</span>,<span class="integer">4</span>,<span class="integer">3</span>,<span class="integer">4</span>,<span class="integer">4</span>,<span class="integer">3</span>,<span class="integer">4</span>,<span class="integer">4</span>,<span class="integer">5</span>,<span class="integer">4</span>,<span class="integer">4</span>,<span class="integer">4</span>,<span class="integer">4</span>};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The rest of the methods are accessors for these fields. Important to mention we do have three constructors</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="comment">// Used in Json serialization</span>
    <span class="directive">public</span> Score()

    <span class="comment">// Creating a new player with course and the courses score card</span>
    <span class="directive">public</span> Score(<span class="predefined-type">String</span> playerName, <span class="predefined-type">String</span> playerId, <span class="predefined-type">String</span> course, <span class="type">int</span><span class="type">[]</span> courseCard)

    <span class="comment">// Creating a new player with defaults</span>
    <span class="directive">public</span> Score(<span class="predefined-type">String</span> playerName, <span class="predefined-type">String</span> playerId)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Take a look at some of the other methods in the Score class and make yourself familiar with it. Do not change the class at this time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_creating_a_service_for_caching">Creating a service for caching</h3>
<div class="paragraph">
<p>So now that you are familiar with the project template, lets start by creating a service. Todo this open ScoreService.java</p>
</div>
<div class="paragraph">
<p>Define the following three class level variables</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    Cache&lt;<span class="predefined-type">Object</span>, Score&gt; scoreCache; <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="predefined-type">Logger</span> log = LoggerFactory.getLogger(ScoreService.class); <i class="conum" data-value="2"></i><b>(2)</b>

    <span class="annotation">@Inject</span>
    EmbeddedCacheManager cacheManager; <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>the scoreCache is an instance of Cache, which will be our point to store and retrieve values. Cache expects &lt;K,V&gt; types, in our case our key is an Object and our actual entry is a Score. Yes the same Score POJO we say earlier. The Cache is also the central interface of Red Hat Data Grid. A Cache provides a highly concurrent, optionally distributed data structure with additional features such as; JTA transaction compatibility, Eviction support for evicting entries from memory to prevent OutOfMemoryErrors, Persisting entries to a CacheLoader, either when they are evicted as an overflow, or all the time, to maintain persistent copies that would withstand server failure or restarts. For convenience, Cache extends ConcurrentMap and implements all methods accordingly. Methods like keySet(), values() and entrySet() produce backing collections in that updates done to them also update the original Cache instance. Certain methods on these maps can be expensive however (prohibitively so when using a distributed cache). The size() and Map.containsValue(Object) methods upon invocation can also be expensive just as well. The reason these methods are expensive are that they take into account entries stored in a configured CacheLoader and remote entries when using a distributed cache.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>the log; straight forward logger incase we want to log something.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>cacheManager; which is an instance of EmbeddedCacheManager, we inject this into our code using the dependency injection and this is possible due to the extension we added in our maven dependencies.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Next let’s create some accessor methods for our service.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="directive">public</span> <span class="predefined-type">List</span>&lt;Score&gt; getAll() { <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;(scoreCache.values());
    }

    <span class="directive">public</span> <span class="type">void</span> save(Score entry) { <i class="conum" data-value="2"></i><b>(2)</b>
        scoreCache.put(getKey(entry), entry);
    }

    <span class="directive">public</span> <span class="type">void</span> delete(Score entry) { <i class="conum" data-value="3"></i><b>(3)</b>
        scoreCache.remove(getKey(entry));
    }

    <span class="directive">public</span> <span class="type">void</span> getEntry(Score entry){ <i class="conum" data-value="4"></i><b>(4)</b>
        scoreCache.get(getKey(entry));
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We get all values from the cache and return them as a List of Scores</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We are saving the entire entry, which we expect as a Score object.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We are deleting an entry from our cache</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Finally we want to get 1 entry from our cache.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>These are simple accessor methods, one thing you might have noticed is the use of the method <code>getKey</code>. This method described as follows has one simple task i.e. to get us the key, which in our case we use as a concatenated string of playerId+course. Since entry always has both of these values we concatenate them here.</p>
</div>
<div class="paragraph">
<p>Add the following methods to your class as well.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">String</span> getKey(Score entry){<i class="conum" data-value="1"></i><b>(1)</b>
        <span class="keyword">return</span> entry.getPlayerId()+<span class="string"><span class="delimiter">"</span><span class="content">,</span><span class="delimiter">"</span></span>+entry.getCourse();
    }

    <span class="directive">public</span> Score findById(<span class="predefined-type">String</span> key) {<i class="conum" data-value="2"></i><b>(2)</b>
        <span class="keyword">return</span> scoreCache.get(key);
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>to get the key, so we have the right combination when we get an entry request to our cache</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>find the entry in our cache incase we get a getOne request from the resource</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Perfect! Almost to our final step for this service. What we are missing is initialization of our CacheManager and then we need to ask the CacheManager to give us a new cache.</p>
</div>
<div class="paragraph">
<p>The CacheManager has many purposes:
- acts as a container for caches and controls their lifecycle
- manages global configuration and common data structures and resources (e.g. thread pools)
- manages clustering</p>
</div>
<div class="paragraph">
<p>A CacheManager is a fairly heavy-weight component, and you will probably want to initialize it early on in your application lifecycle.
For that reason we use the onStart method in this Service to ensure that the CacheManager and Cache are both created at startup. This also benefits us when we change this to clustering mode, more on that in our next lab.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="type">void</span> onStart(<span class="annotation">@Observes</span> <span class="annotation">@Priority</span>(value = <span class="integer">1</span>) StartupEvent ev){
        cacheManager = <span class="keyword">new</span> DefaultCacheManager(); <i class="conum" data-value="1"></i><b>(1)</b>
        ConfigurationBuilder config = <span class="keyword">new</span> ConfigurationBuilder(); <i class="conum" data-value="2"></i><b>(2)</b>

        cacheManager.defineConfiguration(<span class="string"><span class="delimiter">"</span><span class="content">scoreboard</span><span class="delimiter">"</span></span>, config.build()); <i class="conum" data-value="3"></i><b>(3)</b>
        scoreCache = cacheManager.getCache(<span class="string"><span class="delimiter">"</span><span class="content">scoreboard</span><span class="delimiter">"</span></span>); <i class="conum" data-value="4"></i><b>(4)</b>

        log.info(<span class="string"><span class="delimiter">"</span><span class="content">Cache initialized</span><span class="delimiter">"</span></span>);

    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Constructing a CacheManager is done via one of its constructors, which optionally take in a Configuration or a path or URL to a configuration XML file. In our current config we do not need to add much, but use the defaults</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We use defaults for the Configuration builder. its a very handy Object that enables us to define different cache configurations which we will notice further on in this lab.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We are passing our configuration to the CacheManager.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>You obtain Cache instances from the CacheManager by using one of the overloaded getCache(), methods. Note that with getCache(), there is no guarantee that the instance you get is brand-new and empty, since caches are named and shared. Because of this, the CacheManager also acts as a repository of Caches, and is an effective mechanism of looking up or creating Caches on demand. In our case we expect this to be the first Cache and local embedded one. This is also not clustered.</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You might have noticed, that a CacheManager can have multiple Caches; which is great, since in any application you could store multiple unrelated data in different caches, not just that you might even want to have different behaviour with different Caches, e.g. Eviction or Expiration could differ etc. This gives us a lot more to work with then we would in a ConcurrentHashMap as an example.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_creating_a_rest_resource_for_our_app">Creating a REST Resource for our app</h3>
<div class="paragraph">
<p>Lets create our REST resource. This should be simple. Open the ScoreResource.java file.
Since we already implemented most of our code in the service, we need to make sure we can respond on the correct REST calls.</p>
</div>
<div class="paragraph">
<p>First lets inject our ScoreService so we can use all the caching functions we need.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@Inject</span>
    ScoreService scoreService;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lets implement the create end point, here we are simply calling the save function on the scoreService.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@POST</span>
    <span class="annotation">@Transactional</span>
    <span class="directive">public</span> Response create(<span class="annotation">@Valid</span> Score item) {
        scoreService.save(item);
        <span class="keyword">return</span> Response.status(Status.CREATED).entity(item).build();
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>And we also want to be able to get one entry from our cache. following method will do that by calling the scoreService.findById</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@GET</span>
    <span class="annotation">@Path</span>(<span class="string"><span class="delimiter">"</span><span class="content">/{id}</span><span class="delimiter">"</span></span>)
    <span class="directive">public</span> <span class="predefined-type">Object</span> getOne(<span class="annotation">@PathParam</span>(<span class="string"><span class="delimiter">"</span><span class="content">id</span><span class="delimiter">"</span></span>) <span class="predefined-type">String</span> id) {
        <span class="predefined-type">Object</span> entity = scoreService.findById(id);
        <span class="keyword">if</span> (entity == <span class="predefined-constant">null</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> WebApplicationException(<span class="string"><span class="delimiter">"</span><span class="content">ScoreCard with id of </span><span class="delimiter">"</span></span> + id + <span class="string"><span class="delimiter">"</span><span class="content"> does not exist.</span><span class="delimiter">"</span></span>, Status.NOT_FOUND);
        }
        <span class="keyword">return</span> entity;
    }

    <span class="annotation">@GET</span>
    <span class="directive">public</span> <span class="predefined-type">List</span>&lt;Score&gt; getAll() {
        <span class="keyword">return</span> scoreService.getAll();
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>And incase we wanted to update an entry. that would normally the case when we the player is playing the round. so the score will be updated.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@PATCH</span>
    <span class="annotation">@Path</span>(<span class="string"><span class="delimiter">"</span><span class="content">/{id}</span><span class="delimiter">"</span></span>)
    <span class="annotation">@Transactional</span>
    <span class="directive">public</span> Response update(<span class="annotation">@Valid</span> Score card, <span class="annotation">@PathParam</span>(<span class="string"><span class="delimiter">"</span><span class="content">id</span><span class="delimiter">"</span></span>) <span class="predefined-type">Long</span> id) {
        scoreService.save(card);
        <span class="keyword">return</span> Response.status(Status.CREATED).entity(card).build();

    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Take a look into some of the other methods in the ScoreResource to make your self familiar with the code there.</p>
</div>
<div class="paragraph">
<p>If you might have noticed at the class declaration we are using the following annotations</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Produces</span>(MediaType.APPLICATION_JSON) <i class="conum" data-value="1"></i><b>(1)</b>
<span class="annotation">@Consumes</span>(MediaType.APPLICATION_JSON) <i class="conum" data-value="2"></i><b>(2)</b>
<span class="annotation">@Path</span>(<span class="string"><span class="delimiter">"</span><span class="content">/api</span><span class="delimiter">"</span></span>) <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This means we are producing JSON from our responses</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This means we only listen to JSON, this helps us to consume the JSON directly and serialize it into our Score POJO as an example.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>and <code>api</code> is the path to our resource. e.g. localhost:8080/api</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is suggested that at this moment you close all terminal windows that you might have opened in the previous labs. to keep a clear view of our lab</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_run_the_service">Run the Service</h3>
<div class="paragraph">
<p>A quick look at our side bar menu on the right called <code>MyWorkspace</code></p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/codeready-workspace-terminal.png" alt="cdw" width="400">
</div>
</div>
<div class="paragraph">
<p>We will use this menu through out the labs. There is a bunch of commands created specifically for this workshop.</p>
</div>
<div class="paragraph">
<p>First lets login to Openshift. You will find the button in the right corner in MyWorkspace menu.
Click <code>Login to Openshift</code></p>
</div>
<div class="paragraph">
<p>Lets run our project click on the Command <code>Emebdded - Start Live Coding</code>
This will enable Live coding, it will open up a small terminal to build your artifact and then open up a browser view</p>
</div>
<div class="paragraph">
<p>Make sure you click on the Openlink</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/openlinkbox.png" alt="cdw" width="800">
</div>
</div>
<div class="paragraph">
<p>You can also click on the link icon in the browser view, which will open a browser tab.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/embeddedprojectliveview.png" alt="cdw" width="800">
</div>
</div>
<div class="paragraph">
<p>Now open another terminal and change to the scripts directory</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">cd dg8-embedded-quarkus/scripts</code></pre>
</div>
</div>
<div class="paragraph">
<p>now open a terminal form the <code>MyWorkspace</code> menu move to our project directory cd <code>dg8-embedded-quarkus</code> which should be in project root/dg8-workshop/</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">cd dg8-embedded-quarkus</code></pre>
</div>
</div>
<div class="paragraph">
<p>in the scripts directory we have a load.sh file. Open this file in CodeReadyWorkspace and change the variable EP to the applicaiton route from the browser, you can copy it from the browser view in CodeReady or the tab that was openend when you ran the Live Coding. (assuming live coding is still on)
and run load.sh , you can run this file</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">./load.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hit the URL again on the browser veiw and you will see some scores updated. Now these scores were posted directly
&lt;1&gt; via our ScoreResource
&lt;2&gt; into our ScoreService
&lt;3&gt; and passed into the cache</p>
</div>
<div class="paragraph">
<p>We just created a bunch of POST requests, to create a bunch of scores.
The way the algorithm is working is that , we assume the score card is updated after every hole. or at the end. so if you place the data</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">card:5,4,4,4,3,5,0,0,0,0,0,0,0,0,0,0,0,0
course:Bethapage
currentHole:6
playerId:2
playerName:James</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, we are still doing a POST request like before, however the cache is checking whats coming in the put request, it will create the combination key like we have in our Score service i.e. PlayerId+Course and put the new data in it. This means that again its just one call to make this update, no lookups were needed specifically to perform before updating.</p>
</div>
<div class="paragraph">
<p>Try this data entry again, and this time change the course to Firestone, and you will notice that there will be a new entry for James. So now James will have two rounds on the scoreboard.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Its important to know what our key is and its important to find the right combination of what kind of key our data should posses when it comes to a Cache.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Lets do that, enter this data in the form in your browser view and press save, it will updated James’s round score.</p>
</div>
<div class="paragraph">
<p>If you goto your endpoint/api which should be route of your app/api in the browser you will also see the same JSON data there as well.</p>
</div>
<div class="paragraph">
<p>So what we have successfully done so far. Read, Write and update our Cache.</p>
</div>
<div class="paragraph">
<p>Lets move on to the next step and do some more interesing additions to our project.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Since we are using the Live Coding mode here, at any time if you terminate or restart the session it will clear the cache.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_expiration_of_entries">Expiration of Entries</h3>
<div class="paragraph">
<p>Lets assume you are pulling this data off from a database. You might want that it should be removed from the cache after a certain time period.
You can do this by defining this either on the a single entry or the entire cache. By default entries created are immortal and do not have a lifespan or maximum idle time. Using the cache API, mortal entries can be created with lifespans and/or maximum idle times</p>
</div>
<div class="paragraph">
<p>Expiration is a top-level construct, represented in the configuration as well as in the cache API.
- While eviction is local to each cache instance , expiration is cluster-wide . Expiration lifespan and maxIdle values are replicated along with the cache entry.
- Maximum idle times for cache entries require additional network messages in clustered environments. For this reason, setting maxIdle in clustered caches can result in slower operation times.
- Expiration lifespan and maxIdle are also persisted in CacheStores, so this information survives eviction/passivation.</p>
</div>
<div class="paragraph">
<p>Lets start with doing this for one entry.</p>
</div>
<div class="paragraph">
<p>In Infinispan entry expiration can happen in two ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a certain time after the data was inserted into the cache (i.e. lifespan)</p>
</li>
<li>
<p>a certain time after the data was last accessed (i.e. maximum idle time)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Cache interface offers overloaded versions of the put() method that allow specifying either or both expiration properties. The following example shows how to insert an entry which will expire after 5 seconds</p>
</div>
<div class="paragraph">
<p>Open the ScoreService and change the save method to the following.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="directive">public</span> <span class="type">void</span> save(Score entry) {
        scoreCache.put(getKey(entry), entry, <span class="integer">5</span>, <span class="predefined-type">TimeUnit</span>.SECONDS);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above code, we have used TimeUnit and we specify 5 as the unit which is seconds. Following are the units you can use in the TimeUnit</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    NANOSECONDS,
    MICROSECONDS,
    MILLISECONDS,
    SECONDS,
    MINUTES,
    HOURS,
    DAYS;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Okay now its time to test this change.
Go back into the terminal and run load.sh</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">./load.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>Refresh your browser view right away. and you will see the entries again. Now wait for 5 seconds and refresh again.
You will see the entries have expired.
This is becuase we set the timespan to 5 seconds.</p>
</div>
<div class="paragraph">
<p>In the previous step we used the overloaded put() method to store mortal entries. But since we want all of our entries to expire with the same lifespan, we can configure the cache to have default expiration values. To do this we will construct the DefaultCacheManager by passing in a org.infinispan.configuration.cache.Configuration object. A configuration in Infinispan is mostly immutable, aside from some runtime-tunable parameters, and is constructed by means of a ConfigurationBuilder. Using the above use-case, let’s create a cache configuration where we want to set the default expiration of entries to 5 seconds.</p>
</div>
<div class="paragraph">
<p>Add the following line to your ScoreService onStart method; right under the <code>ConfigurationBuilder</code> instantiation</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    config.expiration().lifespan(<span class="integer">5</span>, <span class="predefined-type">TimeUnit</span>.SECONDS);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also change the save implementation back to the following</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="directive">public</span> <span class="type">void</span> save(Score entry) {
        scoreCache.put(getKey(entry), entry);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>and run load.sh</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">./load.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>Refresh your browser view right away. and you will see the entries again. Now wait for 5 seconds and refresh again.
You will see the entries have expired.
This is becuase we set the timespan to 5 seconds for the CacheManager.</p>
</div>
<div class="paragraph">
<p>Now this is a configuration change for the cache and this will expire all entries after 5 seconds.</p>
</div>
<div class="paragraph">
<p><strong>Challenge yourself</strong>: Next task for you is to change the lifespan to 5 minutes and see if that works for you.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When an entry expires it resides in the data container or cache store until it is accessed again by a user request. An expiration reaper is also available to check for expired entries and remove them at a configurable interval of milliseconds. More information can be found in the Product documentation</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_eviction">Eviction</h3>
<div class="paragraph">
<p>Red Hat Data Grid supports eviction of entries, such that you do not run out of memory. Eviction is typically used in conjunction with a cache store, so that entries are not permanently lost when evicted, since eviction only removes entries from memory and not from cache stores or the rest of the cluster. Red Hat Data Grid supports storing data in a few different formats. Data can be stored as the object iself, binary as a byte[], and off-heap which stores the byte[] in native memory.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Eviction occurs on a local basis, and is not cluster-wide. Each node runs an eviction thread to analyse the contents of its in-memory container and decide what to evict. Eviction does not take into account the amount of free memory in the JVM as threshold to starts evicting entries. You have to set size attribute of the eviction element to be greater than zero in order for eviction to be turned on. If size is too large you can run out of memory. The size attribute will probably take some tuning in each use case.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_difference_between_eviction_and_expiration">Difference between Eviction and Expiration</h3>
<div class="paragraph">
<p>Both Eviction and Expiration are means of cleaning the cache of unused entries and thus guarding the heap against OutOfMemory exceptions, so now a brief explanation of the difference.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>With eviction you set maximal number of entries you want to keep in the cache and if this limit is exceeded, some candidates are found to be removed according to a choosen eviction strategy (LRU, LIRS, etc…​). Eviction can be setup to work with passivation, which is eviction to a cache store.</p>
</li>
<li>
<p>With expiration you set time criteria for entries to specify how long you want to keep them in the cache.</p>
</li>
<li>
<p><strong>lifespan</strong> Specifies how long entries can remain in the cache before they expire. The default value is -1, which is unlimited time.</p>
</li>
<li>
<p><strong>maximum idle time</strong> Specifies how long entries can remain idle before they expire. An entry in the cache is idle when no operation is performed with the key. The default value is -1, which is unlimited time.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Perfect now we know what eviction and expiration API we have at our disposal and how we can use them in our app.</p>
</div>
<div class="paragraph">
<p>Add the following line to your ScoreService onStart method; right under the <code>ConfigurationBuilder</code> instantiation; in our example below we are going to limit our Cache to only 2 entries, anything above that will not be added to the Cache.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    config.memory().size(<span class="integer">2</span>).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>and run load.sh</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">./load.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>Refresh your browser view right away. and you will see the entries again. But this time note that there are only two entries. And thats what we had specified in our Cache configuration.</p>
</div>
</div>
<div class="sect2">
<h3 id="_listeners">Listeners</h3>
<div class="paragraph">
<p>Red Hat Data Grid offers a listener API, where clients can register for and get notified when events take place. This annotation-driven API applies to 2 different levels: cache level events and cache manager level events.</p>
</div>
<div class="paragraph">
<p>Events trigger a notification which is dispatched to listeners. Listeners are simple POJO s annotated with @Listener and registered using the methods defined in the Listenable interface.</p>
</div>
<div class="paragraph">
<p>Both Cache and CacheManager implement Listenable, which means you can attach listeners to either a cache or a cache manager, to receive either cache-level or cache manager-level notifications.</p>
</div>
<div class="paragraph">
<p>Implement a new class <code>CacheListener</code></p>
</div>
<div class="paragraph">
<p><strong>1</strong> Create a new Java file, by right clicking on your project’s package name i.e. <code>acme</code>, also shown in the screenshot below</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/newjavafile.png" alt="cdw" width="600">
</div>
</div>
<div class="paragraph">
<p><strong>2</strong> Next specifiy the name of the file <code>CacheListener.java</code> , also in the screenshot below</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/cachelistenerjava.png" alt="cdw" width="600">
</div>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.acme</span>;

<span class="keyword">import</span> <span class="include">org.infinispan.notifications.Listener</span>;
<span class="keyword">import</span> <span class="include">org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated</span>;
<span class="keyword">import</span> <span class="include">org.infinispan.notifications.cachelistener.annotation.CacheEntryModified</span>;
<span class="keyword">import</span> <span class="include">org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent</span>;
<span class="keyword">import</span> <span class="include">org.infinispan.notifications.cachelistener.event.CacheEntryModifiedEvent</span>;

<span class="annotation">@Listener</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">CacheListener</span> {

    <span class="annotation">@CacheEntryCreated</span>
    <span class="directive">public</span> <span class="type">void</span> entryCreated(CacheEntryCreatedEvent&lt;<span class="predefined-type">String</span>, Score&gt; event) {
        <span class="predefined-type">System</span>.out.printf(<span class="string"><span class="delimiter">"</span><span class="content">-- Entry for %s created </span><span class="char">\n</span><span class="delimiter">"</span></span>, event.getType());
    }

    <span class="annotation">@CacheEntryModified</span>
    <span class="directive">public</span> <span class="type">void</span> entryUpdated(CacheEntryModifiedEvent&lt;<span class="predefined-type">String</span>, Score&gt; event){
        <span class="predefined-type">System</span>.out.printf(<span class="string"><span class="delimiter">"</span><span class="content">-- Entry for %s modified</span><span class="char">\n</span><span class="delimiter">"</span></span>, event.getType());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also important is to add this listener to our Cache configuration.
Add the following line to the config</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    scoreCache.addListener(<span class="keyword">new</span> CacheListener());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now if we update the entries in our cache or create new ones; we will see a notification on the our console. Lets test this out.</p>
</div>
<div class="paragraph">
<p>Run load.sh</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">./load.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now check the terminals tab where it says  <code>Embedded - Live Coding</code> you should messages like follows</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">2020-04-16 09:29:38,664 INFO  [org.acm.ScoreService] (vert.x-worker-thread-3) Cache initialized
2020-04-16 09:29:38,665 INFO  [io.quarkus] (vert.x-worker-thread-3) jcache-quarkus 1.0.0-SNAPSHOT (powered by Quarkus 1.3.2.Final) started in 0.074s. Listening on: http://0.0.0.0:8080
2020-04-16 09:29:38,665 INFO  [io.quarkus] (vert.x-worker-thread-3) Profile dev activated. Live Coding activated.
2020-04-16 09:29:38,665 INFO  [io.quarkus] (vert.x-worker-thread-3) Installed features: [cdi, infinispan-embedded, kubernetes, resteasy, resteasy-jsonb, smallrye-metrics]
2020-04-16 09:29:38,666 INFO  [io.qua.dev] (vert.x-worker-thread-3) Hot replace total time: 0.371s
-- Entry for CACHE_ENTRY_CREATED created
-- Entry for CACHE_ENTRY_CREATED created
-- Entry for CACHE_ENTRY_CREATED created
-- Entry for CACHE_ENTRY_CREATED created
-- Entry for CACHE_ENTRY_CREATED created
-- Entry for CACHE_ENTRY_CREATED created
-- Entry for CACHE_ENTRY_CREATED created
-- Entry for CACHE_ENTRY_MODIFIED modified</code></pre>
</div>
</div>
<div class="paragraph">
<p>if you start to re run the load.sh a couple of times, you will start to see the modified messages more frequently. Assuming that the lifespan of the cache is more then 5 seconds.</p>
</div>
<div class="paragraph">
<p>Congratulations we are at the end of this lab!</p>
</div>
</div>
<div class="sect2">
<h3 id="_recap">Recap</h3>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>You created our own Cache and learnt how to us EmbeddedCacheManager</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>You learnt how to use ConfigurationBuilder and Configuration objects to define our Configurations for the Cache and CacheManager</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>You learnt about Expiration and Eviction</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>And lastly you implemented your own Listener.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><strong>*Congratulations!!</strong> you have completed the first lab of this workshop. Lets move to the next lab and learn how we can cluster this Cache and also deploy this on a cloud environment like Openshift.</p>
</div>
</div>
</div>
</div>
        <hr>
        <h2>Embedded Clustered Cache</h2>
        <div class="sect1">
<h2 id="_embeded_cache_with_a_cluster">Embeded Cache with a cluster</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this lab we are going to cluster the embedded cache. Inifinispan does this very nicely. We do not need to change a lot of configuration to achieve this.
After configuration, we will deploy our application to Openshift and see how the cluster will work in a cloud environment.
Following diagram illustrates the topology we want to achieve. Although clustering cache nodes can be in 100s, we will start with a couple of them and see how we can get the feature set we need for a cache.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/clusteredembeddedcache.png" alt="Caching" width="900">
</div>
</div>
<div class="sect2">
<h3 id="_clustering">Clustering</h3>
<div class="paragraph">
<p>Open the ScoreService.java again in our project <code>dg8-embedded-quarkus</code></p>
</div>
<div class="paragraph">
<p>We are going to add the following lines of code to our onStart method</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        GlobalConfigurationBuilder global = GlobalConfigurationBuilder.defaultClusteredBuilder();
        global.transport().clusterName(<span class="string"><span class="delimiter">"</span><span class="content">ScoreCard</span><span class="delimiter">"</span></span>);
        cacheManager = <span class="keyword">new</span> DefaultCacheManager(global.build());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Copy the and replace the onStart method in our ScoreService.java</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="type">void</span> onStart(<span class="annotation">@Observes</span> <span class="annotation">@Priority</span>(value = <span class="integer">1</span>) StartupEvent ev){
        GlobalConfigurationBuilder global = GlobalConfigurationBuilder.defaultClusteredBuilder();
        global.transport().clusterName(<span class="string"><span class="delimiter">"</span><span class="content">ScoreCard</span><span class="delimiter">"</span></span>);
        cacheManager = <span class="keyword">new</span> DefaultCacheManager(global.build());

        ConfigurationBuilder config = <span class="keyword">new</span> ConfigurationBuilder();

        config.expiration().lifespan(<span class="integer">5</span>, <span class="predefined-type">TimeUnit</span>.MINUTES)
                .clustering().cacheMode(CacheMode.DIST_SYNC);

        cacheManager.defineConfiguration(<span class="string"><span class="delimiter">"</span><span class="content">scoreboard</span><span class="delimiter">"</span></span>, config.build());
        scoreCache = cacheManager.getCache(<span class="string"><span class="delimiter">"</span><span class="content">scoreboard</span><span class="delimiter">"</span></span>);
        scoreCache.addListener(<span class="keyword">new</span> CacheListener());


        log.info(<span class="string"><span class="delimiter">"</span><span class="content">Cache initialized</span><span class="delimiter">"</span></span>);

    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We define a global configuration, since we are going to be in a clustered mode, hence everytime a new instance of our app will be created it will have the global configuration parameters to talk to the other nodes if they are present.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Infinispan nodes rely on a transport layer to join and leave clusters as well as to replicate data across the network. Infinispan uses JGroups technology to handle cluster transport. You configure cluster transport with JGroups stacks, which define properties for either UDP or TCP protocols. Here we have defined a unique clusterName for our app’s embedded cache</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We setup a distributed cache, which means that not all our nodes will have all the keys.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>We will take a look into replicaiton and distribution furhter in this lab.</p>
</div>
<div class="paragraph">
<p>Also open the CacheListener and make sure that the following line is changed to <code>@Listener(clustered = true)</code></p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Listener</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>By doing this we are making sure we have a clustered listener. And that we can listen to the cross cluster events. so we know exactly in case of key distribution.</p>
</div>
<div class="paragraph">
<p>This all looks in order. lets compile our application.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is suggested that at this moment you close all terminal windows that you might have opened in the previous labs. to keep a clear view of our lab</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>A quick look at our side bar menu on the right called <code>MyWorkspace</code></p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/codeready-workspace-terminal.png" alt="cdw" width="400">
</div>
</div>
<div class="paragraph">
<p>We will use this menu through out the labs. There is a bunch of commands created specifically for this workshop.</p>
</div>
<div class="paragraph">
<p>First lets login to Openshift. You will find the button in the right corner in MyWorkspace menu.
Click <code>Login to Openshift</code></p>
</div>
<div class="paragraph">
<p>Lets run our project click on the Command <code>Emebdded - Start Live Coding</code>
This will enable Live coding, it will open up a small terminal to build your artifact and then open up a browser view</p>
</div>
<div class="paragraph">
<p>Make sure you click on the Openlink</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/openlinkbox.png" alt="cdw" width="800">
</div>
</div>
<div class="paragraph">
<p>You can also click on the link icon in the browser view, which will open a browser tab.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/embeddedprojectliveview.png" alt="cdw" width="800">
</div>
</div>
<div class="paragraph">
<p>If all of this is working lets make sure we can deploy this applicaiton.</p>
</div>
<div class="paragraph">
<p>First run the following command to add the Openshift extension for Quarkus
The Openshift extension makes it easy to deploy your application to openshift, rather then taking all the different steps from an oc command line, you can do that through your maven build.</p>
</div>
<div class="paragraph">
<p>run the following in your terminal, you should see a build successfull message when done.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">mvn quarkus:add-extension -Dextensions="openshift"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now open the application.properties file in <code>src/main/resources/application.properites</code></p>
</div>
<div class="paragraph">
<p>Add the following properties to it</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">quarkus.http.cors=true
quarkus.openshift.expose=true <i class="conum" data-value="1"></i><b>(1)</b>

# if you dont set this and dont have a valid cert the deployment wont happen
quarkus.kubernetes-client.trust-certs=true <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The first property makes sure that once our application is deployed it will expose a route</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The second property makes sure that incase you dont have valid certificates the build wont stop. in our case that can likely be the case since its not a production environment rather a demo one.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Now go to your MyWorkspace menu and Login to Openshift.</p>
</div>
<div class="paragraph">
<p>Perfect everything is inorder. Make sure you are logged into openshift. If you are not sure. You can run the following command in your terminal.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">oc whoami</code></pre>
</div>
</div>
<div class="paragraph">
<p>The command should return your user name: user19 , is you are logged in.</p>
</div>
<div class="paragraph">
<p>Lets first create an image namespace for our application</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">mvn clean package -Dquarkus.container-image.build=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should see a build successful message at the end. That mean everything worked out.</p>
</div>
<div class="paragraph">
<p>Now lets deploy our application to Openshift</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">mvn clean package -Dquarkus.kubernetes.deploy=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also remmember next time we need to deploy we just need to run the above deploy command again. thats all!</p>
</div>
<div class="paragraph">
<p>Lets wait for this build to be successfull!</p>
</div>
</div>
<div class="sect2">
<h3 id="_openshift_console">Openshift Console</h3>
<div class="paragraph">
<p>First, open a new browser with the <a href="https://console-openshift-console.apps.cluster-cph-b051.cph-b051.example.opentlc.com/" target="_blank" rel="noopener">OpenShift web console</a></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/openshift_login.png" alt="openshift_login" width="700">
</div>
</div>
<div class="paragraph">
<p>Login using:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Username: <code>user19</code></p>
</li>
<li>
<p>Password: <code>openshift!</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When you access the <a href="https://console-openshift-console.apps.cluster-cph-b051.cph-b051.example.opentlc.com/">OpenShift web console</a> or other URLs via <em>HTTPS</em> protocol, you might see browser warnings like <code>Your Connection is not secure</code> since this workshop uses self-signed certificates (which you should not do in production!). For example, if you’re using <strong>Chrome</strong>, to accept the warning, Click on <code>Advanced</code> then <code>Proceed to…​</code> to access the page.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Other modern browsers most likely have similar procedures to accept the security exception.</p>
</div>
<div class="paragraph">
<p>You should see something as follows</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/openshiftprojectview.png" alt="Caching" width="900">
</div>
</div>
<div class="paragraph">
<p>Click on the project name and you should see something similar</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/lab2ocpoverview.png" alt="Caching" width="900">
</div>
</div>
<div class="paragraph">
<p>Click on resources, And at the bottom you will see the route to your application. You can also click at the route and it will take you to the application page, same as we have done in the previous lab. if append /api to the url you will be on the api endpoint.</p>
</div>
<div class="paragraph">
<p>Now go back to the overview page for the applicaiton and Click on the pod scaler and scale to 2 pods.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/lab2podscaler.png" alt="Caching" width="900">
</div>
</div>
<div class="paragraph">
<p>Now open another terminal in CodeReady workspaces and change to the scripts directory</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">cd dg8-embedded-quarkus/scripts</code></pre>
</div>
</div>
<div class="paragraph">
<p>in this directory we have a load.sh file. Open this file in CodeReadyWorkspace and change the variable EP to the applicaiton route from the browser
and run load.sh</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">./load.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>Go back to the resrouce view of your application and then click view logs, you should see something as follows.</p>
</div>
<div class="paragraph">
<p>Node1:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/distsyncnode1.png" alt="Caching" width="900">
</div>
</div>
<div class="paragraph">
<p>Node2:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/distsyncnode2.png" alt="Caching" width="900">
</div>
</div>
<div class="paragraph">
<p>Notice in the above screenshots how the keys are distributed between the two nodes.</p>
</div>
<div class="paragraph">
<p>This wont be the case if we were replicating these entries.
So lets go ahead and setup a replicated cache instead. Open the score service and change the Cache config as shown below. Remember the onStart method has the configuration.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        config.expiration().lifespan(<span class="integer">5</span>, <span class="predefined-type">TimeUnit</span>.MINUTES)
                .clustering().cacheMode(CacheMode.REPL_SYNC)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Before we deploy we also need to make sure that the Listener is no longer listening to events clusterwide. we want to listen to events only on the node they are happening on. For this lets make a small config change to our Listener annotation in our class CacheListener</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Listener</span>(primaryOnly = <span class="predefined-constant">false</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is possible in a non transactional cache to receive duplicate events. This is possible when the primary owner of a key goes down while trying to perform a write operation such as a put. Infinispan internally will rectify the put operation by sending it to the new primary owner for the given key automatically, however there are no guarantees in regards to if the write was first replicated to backups. Thus more than 1 of the following write events (CacheEntryCreatedEvent, CacheEntryModifiedEvent &amp; CacheEntryRemovedEvent) may be sent on a single operation.</p>
</div>
<div class="paragraph">
<p>Perfect, now we are all set to deploy again.</p>
</div>
<div class="paragraph">
<p>Now lets deploy our application to Openshift</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">mvn clean package -Dquarkus.kubernetes.deploy=true</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Scale the pods</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>run the load.sh script once the pods are running</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Check the log files and you should see a similar output as below</td>
</tr>
</tbody></table>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/replicatedsyncnode.png" alt="Caching" width="900">
</div>
</div>
<div class="paragraph">
<p>Feel free to change the listner annotation in different modes and try out to see how the events are recieved.</p>
</div>
</div>
<div class="sect2">
<h3 id="_design_considerations">Design Considerations</h3>
<div class="paragraph">
<p>Firstly, p2p deployments are simpler than client-server ones because in p2p, all peers are equals to each other and this simplifies deployment. If this is the first time you are using Infinispan, p2p is likely to be easier for you to get going compared to client-server.</p>
</div>
<div class="paragraph">
<p>Client-server Infinispan requests are likely to take longer compared to p2p requests, due to the serialization and network cost in remote calls. So, this is an important factor to take in account when designing your application. For example, with replicated Infinispan caches, it might be more performant to have lightweight HTTP clients connecting to a server side application that accesses Infinispan in p2p mode, rather than having more heavyweight client side apps talking to Infinispan in client-server mode, particularly if data size handled is rather large. With distributed caches, the difference might not be so big because even in p2p deployments, you’re not guaranteed to have all data available locally.</p>
</div>
<div class="paragraph">
<p>Environments where application tier elasticity is not important, or where server side applications access state-transfer-disabled, replicated Infinispan cache instances are amongst scenarios where Infinispan p2p deployments can be more suited than client-server ones.</p>
</div>
<div class="paragraph">
<p>Congratulations we are at the end of this lab!</p>
</div>
</div>
<div class="sect2">
<h3 id="_recap">Recap</h3>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>You created our own Cache and learnt how to us EmbeddedCacheManager</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>You learnt how to use ConfigurationBuilder and Configuration objects to define our Configurations for the Cache and CacheManager</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>You learnt about how to create and Embedded Cluster</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>You learnt how to deploy a Quarkus application with emebedded cache and scale it.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>You learnt the difference between Replicated and Distributed Cache and how clustering and listeners works.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><strong>*Congratulations!!</strong> you have completed the second lab of this workshop. Lets move to the next lab and learn how we can create a remote cache and how it can benefit our applications.</p>
</div>
</div>
</div>
</div>
        <hr>
        <h2>Operators and RHDG 8</h2>
        <div class="sect2">
<h3 id="_deployment_whats_an_operator_and_how_does_it_help_us">Deployment: What’s an Operator and how does it help us?</h3>
<div class="paragraph">
<p>An Operator is a method of packaging, deploying and managing a Kubernetes-native application. A Kubernetes-native application is an application that is both deployed on Kubernetes and managed using the Kubernetes APIs and kubectl tooling. An Operator is essentially a custom controller.
A controller is a core concept in Kubernetes and is implemented as a software loop that runs continuously on the Kubernetes master nodes comparing, and if necessary, reconciling the expressed desired state and the current state of an object. Objects are well known resources like Pods, Services, ConfigMaps, or PersistentVolumes. Operators apply this model at the level of entire applications and are, in effect, application-specific controllers.</p>
</div>
<div class="paragraph">
<p>The Operator is a piece of software running in a Pod on the cluster, interacting with the Kubernetes API server. It introduces new object types through Custom Resource Definitions, an extension mechanism in Kubernetes. These custom objects are the primary interface for a user; consistent with the resource-based interaction model on the Kubernetes cluster.</p>
</div>
<div class="paragraph">
<p>An Operator watches for these custom resource types and is notified about their presence or modification. When the Operator receives this notification it will start running a loop to ensure that all the required connections for the application service represented by these objects are actually available and configured in the way the user expressed in the object’s specification.</p>
</div>
<div class="paragraph">
<p>The Operator Lifecycle Manager (OLM) is the backplane that facilitates management of operators on a Kubernetes cluster. Operators that provide popular applications as a service are going to be long-lived workloads with, potentially, lots of permissions on the cluster.</p>
</div>
<div class="paragraph">
<p>With OLM, administrators can control which Operators are available in what namespaces and who can interact with running Operators. The permissions of an Operator are accurately configured automatically to follow a least-privilege approach. OLM manages the overall lifecycle of Operators and their resources, by doing things like resolving dependencies on other Operators, triggering updates to both an Operator and the application it manages, or granting a team access to an Operator for their slice of the cluster.</p>
</div>
<div class="paragraph">
<p>Red Hat Data Grid 8.0 comes with an Operator. The administrators of the cluster have already installed the Data Grid Operator, what we need to do as a user is define a Custom Resource as to how and what configuration we want for our Red Hat Data Grid instances.</p>
</div>
</div>
<div class="sect2">
<h3 id="_installing">Installing</h3>
<div class="paragraph">
<p>Assuming you have already logged in to openshift from the CodeReady terminal, if not you can do it now. Click on the <code>Login to Openshift</code> menu in the right menu called 'My Workspace'.</p>
</div>
<div class="paragraph">
<p>First, open a new browser with the <a href="https://console-openshift-console.apps.cluster-cph-b051.cph-b051.example.opentlc.com/" target="_blank" rel="noopener">OpenShift web console</a></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/openshift_login.png" alt="openshift_login" width="700">
</div>
</div>
<div class="paragraph">
<p>Login using:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Username: <code>user19</code></p>
</li>
<li>
<p>Password: <code>openshift!</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Once Logged in, goto your project <code>user19-cache</code>
Click the link Installed Operator on the left, as shown in the picture below.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/dg_operatorinstalled.png" alt="openshift_login" width="700">
</div>
</div>
<div class="paragraph">
<p>Notice that the DataGrid operator is already installed in your namespace.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/dg_operatoroverview.png" alt="openshift_login" width="700">
</div>
</div>
<div class="paragraph">
<p>You can see there are no clusters installed in our namespace. Lets go ahead and do that.</p>
</div>
<div class="paragraph">
<p>You can press the <code>Create Infinispan</code> and create a CR (Custom Resource) from the console as well.</p>
</div>
<div class="paragraph">
<p>Or you can also follow the instructions to deploy a CR below.</p>
</div>
<div class="paragraph">
<p>Lets start by installing a basic Red Hat Data Grid Cluster.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="yaml">    <span class="key">apiVersion</span>: <span class="string"><span class="content">infinispan.org/v1</span></span>
    <span class="key">kind</span>: <span class="string"><span class="content">Infinispan </span></span><i class="conum" data-value="1"></i><b>(1)</b>
    <span class="key">metadata</span>:
    <span class="key">name</span>: <span class="string"><span class="content">datagrid-service </span></span><i class="conum" data-value="2"></i><b>(2)</b>
    <span class="key">spec</span>:
    <span class="key">replicas</span>: <span class="string"><span class="content">2 </span></span><i class="conum" data-value="3"></i><b>(3)</b>
    <span class="key">expose</span>:
        <span class="key">type</span>: <span class="string"><span class="content">LoadBalancer </span></span><i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>Create a file with name cr_minimal.yaml copy and paste the above defination and save it.</p>
</div>
<div class="paragraph">
<p>Before applying this defination, lets take a look how its constructed.</p>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>tells Kubernetes/Openshift that the Custom resource type is Infinispan</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>we specify the name of our cluster as datagrid-service</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>we specify the replicas we want for our service.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>And finally we want this instance to be accessible from outside openshift. e.g. the console;</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Also notice that we are calling our service <code>datagrid-service</code>, we will use this name in the following labs to access our cluster.</p>
</div>
<div class="paragraph">
<p>Now from the terminal use the oc command line to apply it.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">oc apply -f cr_minimal.yaml</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can watch the Red Hat Data Grid Operator creating the instances by running the following command.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">oc get pods -w</code></pre>
</div>
</div>
<div class="paragraph">
<p>Above command should render a similar output as below</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">[jboss@workspacel7b3gw19zpoclvcu dg8-operator]$ oc get pods
NAME                                   READY   STATUS      RESTARTS   AGE
datagrid-service-0                     0/1     Running     0          43s
infinispan-operator-5bb557597f-vl88n   1/1     Running     0          24h</code></pre>
</div>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">oc get services</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above command should render a similar output as shown in the example below. Showing all the services</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/dg_operatorserviceview.png" alt="openshift_login" width="900">
</div>
</div>
<div class="paragraph">
<p>You can see that there are three datagrid-services,</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1 for use within the cluster,</p>
</li>
<li>
<p>1 for ping service which ensures that the clusters are healthy and operational</p>
</li>
<li>
<p>and lastly the external service, which we will use to goto the Admin console.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Run the following command to get the loadbalancer address</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">oc get services | grep datagrid-service-external | awk '{ print $4 }'</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see we have a service with our LoadBalancer. Lets get that url and paste it in the browser as follows</p>
</div>
<div class="paragraph">
<p>The following is an example, your loadbalancer url might differ</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">http://ad6cd35d6e6aa46fcb96558204c35f08-872149037.us-east-1.elb.amazonaws.com:11222</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you try to access the url; you would need to provide credentials.</p>
</div>
<div class="paragraph">
<p>The datagrid operator creates the credentials during installation time and they should be stored in your namespace secrets. Lets get the secret with the following command.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">oc get secret datagrid-service-generated-secret -o jsonpath="{.data.identities\.yaml}" | base64 --decode</code></pre>
</div>
</div>
<div class="paragraph">
<p>And now the final test to check we have a running cluster; login with the username developer and the password from the above secret.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/dg_adminconsole.png" alt="openshift_login" width="900">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_recap">Recap</h3>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>You created your own CR</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Deployed the CR to Openshift using the DataGrid operator</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>You installed your DataGrid instance</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><strong>*Congratulations!!</strong> you have completed the first Datagrid installation of this workshop. Lets move to the next lab and learn how we can use this instance as a RemoteCache with a Quarkus Application.</p>
</div>
</div>
        <hr>
        <h2>Remote Cache</h2>
        <div class="sect2">
<h3 id="_hotrod_client">HotRod Client</h3>
<div class="paragraph">
<p>Hot Rod is a binary TCP protocol that Infinispan offers high-performance client-server interactions with the following capabilities:
- Load balancing. Hot Rod clients can send requests across Infinispan clusters using different strategies to increase reliability.
- Failover. Hot Rod clients can monitor Infinispan cluster topology changes and automatically switch to available nodes to ensure requests never go to offline nodes.
- Efficient data location. Hot Rod clients can find key owners and make requests directly to those nodes, which reduces latency.</p>
</div>
</div>
<div class="sect2">
<h3 id="_remotecache">RemoteCache</h3>
<div class="paragraph">
<p>RemoteCache as the name suggest is accessed remotely. The Datagrid server will host this remote cache, and clients will connect to this remote cache.
From a design perspective it gives more flexibility and also allows to have central deployments with multiple caches residing in it; there by making managemetn and operations a bit more simpler.</p>
</div>
<div class="paragraph">
<p>There are some symantic differences how Inifinspan/Red Hat Data Grid expose RemoteCache vs EmbeddedCache. The collection methods keySet, entrySet and values are backed by the remote cache. That is that every method is called back into the RemoteCache. This is useful as it allows for the various keys, entries or values to be retrieved lazily, and not requiring them all be stored in the client memory at once if the user does not want. These collections adhere to the Map specification being that add and addAll are not supported but all other methods are supported. One thing to note is the Iterator.remove and Set.remove or Collection.remove methods require more than 1 round trip to the server to operate. You can check out the RemoteCache Javadoc to see more details about these and the other methods.</p>
</div>
</div>
<div class="sect2">
<h3 id="_project_details">Project details</h3>
<div class="paragraph">
<p>For this example we are going to create a simple web application. it will take some input from a webform and then add the entries into the Cache.
However in this case we will be using the RemoteCacheManager and we will be using ProtoStream API. All of this with a Quarkus based application.</p>
</div>
<div class="paragraph">
<p>So let’s get cracking. But first lets checkout the template project.</p>
</div>
<div class="paragraph">
<p>Navigate to the project <code>dg8-quarkus-client-example</code>
This is a template project, and you will be writing code into this project.
As you can see there is already some files inplace. Lets take a look into what these files are and do.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_maven_dependencies">The Maven dependencies</h3>
<div class="paragraph">
<p>Open the pom.xml file in the project.</p>
</div>
<div class="paragraph">
<p>We will be using the following dependencies to create our service</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="maven">    &lt;dependency&gt;
      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
      &lt;artifactId&gt;quarkus-resteasy&lt;/artifactId&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
      &lt;artifactId&gt;quarkus-resteasy-jsonb&lt;/artifactId&gt; <i class="conum" data-value="2"></i><b>(2)</b>
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
      &lt;artifactId&gt;quarkus-infinispan-client&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>quarkus-resteasy; for our REST endpoint</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>quarkus-resteasy-jsonb; we will use this for Json serialization for our REST endpoint</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>quarkus-infinispan-client; This extension will enable us to use RemoteCache</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_protobuf">Protobuf</h3>
<div class="paragraph">
<p>Protobuf or Protocol Buffers are a method of serializing structured data. Protocol buffers are a flexible, efficient, automated mechanism for serializing structured data; they are much smaller and simpler in expression. You can easily write and read your structured data to and from a variety of data streams and using a variety of languages. Protobuf is all about structured data, so the first thing to do is to define the structure of your data. This is accomplished by declaring Protobuf message types in .proto files. e.g the game.proto file looks like follows.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="protobuf">package quickstart; <i class="conum" data-value="1"></i><b>(1)</b>

message Game{ <i class="conum" data-value="2"></i><b>(2)</b>
    required string name = 2; <i class="conum" data-value="3"></i><b>(3)</b>
    required string description = 3; <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Save the above content in the following file src/main/resources/META-INF/game.proto</p>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We define a package for our entity.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>this is the name of our message. A message is similar to an entity.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>we specify that our type <code>string name</code> is required.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>and same for our next field description.</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_marshallers">Marshallers</h3>
<div class="paragraph">
<p>As described in the previous section, a fundamental concept of the Protobuf format is the definition of messages in the .proto schema to determine how an entity is represented. However, in order for our Java applications to utilise the Protobuf format to transmit/store data, it’s necessary for our Java objects to be encoded. This is handled by the ProtoStream library and its configured Marshaller implementations, which convert plain old Java objects into the Protobuf format.</p>
</div>
<div class="paragraph">
<p>Although generating resources is the easiest and most performant way to utilise ProtoStream, this method might not always be viable. For example, if you are not able to modify the Java object classes to add the required annotations. For such use cases, it’s possible to manually define the .proto schema and create a manual marshaller implementation. Lets define our Marshaller; Open the GameMarshaller class</p>
</div>
<div class="paragraph">
<p>Add the following method to our GameMarshaller.
In the following code we specify how we are going to read from our ProtoStream. We could add any additional processing on the stream if we wanted to. For now we take a simplified read and return a Game Object. Hence everytime a stream is read from the Cache, this method will be called.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@Override</span>
    <span class="directive">public</span> Game readFrom(MessageMarshaller.ProtoStreamReader reader) <span class="directive">throws</span> <span class="exception">IOException</span> {
        <span class="predefined-type">String</span> name = reader.readString(<span class="string"><span class="delimiter">"</span><span class="content">name</span><span class="delimiter">"</span></span>);
        <span class="predefined-type">String</span> description = reader.readString(<span class="string"><span class="delimiter">"</span><span class="content">description</span><span class="delimiter">"</span></span>);
        <span class="keyword">return</span> <span class="keyword">new</span> Game(name, description);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next we can also define a writer method. It takes a Game object and translates that into a stream.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> writeTo(MessageMarshaller.ProtoStreamWriter writer, Game game) <span class="directive">throws</span> <span class="exception">IOException</span> {
        writer.writeString(<span class="string"><span class="delimiter">"</span><span class="content">name</span><span class="delimiter">"</span></span>, game.getName());
        writer.writeString(<span class="string"><span class="delimiter">"</span><span class="content">description</span><span class="delimiter">"</span></span>, game.getDescription());
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lets specify which class handles our Stream data.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> Game&gt; getJavaClass() {
        <span class="keyword">return</span> Game.class;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>And finally here we let the Serialization process know what type we are doing this for. i.e. packagename.Class</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> getTypeName() {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">"</span><span class="content">quickstart.Game</span><span class="delimiter">"</span></span>;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Perfect we have our Marshaller configured.</p>
</div>
</div>
<div class="sect2">
<h3 id="_configuring_our_remotecache">Configuring our RemoteCache</h3>
<div class="paragraph">
<p>Let’s move on and create our RemoteCache configuration</p>
</div>
<div class="paragraph">
<p>For this open the Init.java and add the following member variables to it.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> GAME_CACHE = <span class="string"><span class="delimiter">"</span><span class="content">games</span><span class="delimiter">"</span></span>; <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="annotation">@Inject</span>
    RemoteCacheManager cacheManager; <i class="conum" data-value="2"></i><b>(2)</b>

    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> CACHE_CONFIG = <i class="conum" data-value="3"></i><b>(3)</b>
            <span class="string"><span class="delimiter">"</span><span class="content">&lt;infinispan&gt;&lt;cache-container&gt;</span><span class="delimiter">"</span></span> +
                    <span class="string"><span class="delimiter">"</span><span class="content">&lt;distributed-cache name=</span><span class="char">\"</span><span class="content">%s</span><span class="char">\"</span><span class="content">&gt;&lt;/distributed-cache&gt;</span><span class="delimiter">"</span></span> +
                    <span class="string"><span class="delimiter">"</span><span class="content">&lt;/cache-container&gt;&lt;/infinispan&gt;</span><span class="delimiter">"</span></span>;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>First we specify a class level variable which is the name of our Cache.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We inject the cacheManager to our file. We only want to load the CacheManager once, and since its a heavy object, we want to do it at startup.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>As we learnt in the previous section we can also configure a cache with xml, we are exactly doing that here. We could have also loaded this from a file META-INF but for a short demo this works okay.</td>
</tr>
</tbody></table>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="type">void</span> onStart(<span class="annotation">@Observes</span> <span class="annotation">@Priority</span>(value = <span class="integer">1</span>) StartupEvent ev) {
        <span class="predefined-type">String</span> xml = <span class="predefined-type">String</span>.format(CACHE_CONFIG, <span class="string"><span class="delimiter">"</span><span class="content">games</span><span class="delimiter">"</span></span>); <i class="conum" data-value="1"></i><b>(1)</b>
        cacheManager.administration().getOrCreateCache(GAME_CACHE, <span class="keyword">new</span> XMLStringConfiguration(xml)); <i class="conum" data-value="2"></i><b>(2)</b>
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You might remember the onStart from our previous lab. We are doing the same thing here.
&lt;1&gt; we use the xml defined in a String and pass it on to the Red Hat Data Grid server to parse it and create a new cache called games
&lt;2&gt; then we ask the cacheManager to get the Cache for us or create a new one if it doesnt exist.</p>
</div>
<div class="paragraph">
<p>By now we should have a RemoteCacheManager configured, all we need to do now is to inject it in out REST resource.</p>
</div>
</div>
<div class="sect2">
<h3 id="_rest_endpoint">REST endpoint</h3>
<div class="paragraph">
<p>Open up the GameResource.java, this is our REST resource file use the resteasy dependencies.</p>
</div>
<div class="paragraph">
<p>In the following code we inject or RemoteCache, and we specify which Remote cache we want by passing the variable GAME_CACHE to it, which we have initialized previously in our Init.java
Add this code to the GameResource.java</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@Inject</span>
    <span class="annotation">@Remote</span>(GAME_CACHE)
    RemoteCache&lt;<span class="predefined-type">String</span>, Game&gt; gameStore;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are two simple GET and POST method implementation.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@GET</span>
    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;Game&gt; list() {
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;&gt;(gameStore.values());
    }

    <span class="annotation">@POST</span>
    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt; add(Game game) {
        gameStore.putAsync(game.getName(), game);
        <span class="keyword">return</span> gameStore.keySet();
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>the list method is simply posting back a HashSet back to the front-end</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>and here the add method is using the Async api of infinispan/Red Hat Data Grid to add the entry into the cache.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Perfect. We are all set to deploy our application to Openshift and see how the RemoteCache will work.</p>
</div>
</div>
<div class="sect2">
<h3 id="_deploying_to_openshift_and_scaling">Deploying to Openshift and scaling</h3>
<div class="paragraph">
<p>Lets prepare to deploy the application to Openshift</p>
</div>
<div class="paragraph">
<p>For this open up the application.properties located at src/main/resources/application.properties</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="properties">quarkus.infinispan-client.server-list=datagrid-service:11222<i class="conum" data-value="1"></i><b>(1)</b>
quarkus.infinispan-client.client-intelligence=BASIC<i class="conum" data-value="2"></i><b>(2)</b>
quarkus.infinispan-client.auth-username=developer<i class="conum" data-value="3"></i><b>(3)</b>
quarkus.infinispan-client.auth-password=<i class="conum" data-value="4"></i><b>(4)</b>


quarkus.http.cors=true

# Openshift extension settings.
quarkus.openshift.expose=true <i class="conum" data-value="5"></i><b>(5)</b>

# if you dont set this and dont have a valid cert the deployment wont happen

quarkus.kubernetes-client.trust-certs=true<i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Sets the host name/port to connect to. Each one is separated by a semicolon (eg. host1:11222;host2:11222)</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Sets client intelligence used by authentication , in our case its basic, since we deployed a minimal server config</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Sets user name used by authentication, in our case its developer, thats the default from the operator.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Sets password used by authentication, we do not have this yet. we will find it out from the secrets.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>we make sure that our applications route will be exposed once its deployed.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Finally we also put this property to true, incase our server does not have trusted certificates, which in our case can be true, since we are in a demo denvironment.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Lets go fill that password field in the above properties file.</p>
</div>
<div class="paragraph">
<p>Run the following command on the terminal and the password will be shown, then copy that password and add it to the password field <code>quarkus.infinispan-client.auth-password=</code>.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">    oc get secret datagrid-service-generated-secret -o jsonpath="{.data.identities\.yaml}" | base64 --decode</code></pre>
</div>
</div>
<div class="paragraph">
<p>Save the application.properties file.</p>
</div>
<div class="paragraph">
<p>Lets go ahead and deploy the application to openshift.
Now go to your MyWorkspace menu and Login to Openshift.</p>
</div>
<div class="paragraph">
<p>Perfect everything is inorder.</p>
</div>
<div class="paragraph">
<p>Lets first create an image namespace for our application</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">mvn clean package -Dquarkus.container-image.build=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should see a build successful message at the end. That mean everything worked out.</p>
</div>
<div class="paragraph">
<p>Now lets deploy our application to Openshift</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">mvn clean package -Dquarkus.kubernetes.deploy=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also remmember next time we need to deploy we just need to run the above deploy command again. thats all!</p>
</div>
<div class="paragraph">
<p>Lets wait for this build to be successfull!</p>
</div>
<div class="paragraph">
<p>Now navigate to the openshift console</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/gameserviceocp.png" alt="cdw" width="700">
</div>
</div>
<div class="paragraph">
<p>And click on the resources/routes to navigate to the application</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/gamerestservice.png" alt="cdw" width="700">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_enabling_near_cache">Enabling Near Cache</h3>
<div class="paragraph">
<p>Near caches are optional caches for Hot Rod Java client implementations that keep recently accessed data close to the user, providing faster access to data that is accessed frequently. This cache acts as a local Hot Rod client cache that is updated whenever a remote entry is retrieved via get or getVersioned operations.</p>
</div>
<div class="paragraph">
<p>In Red Hat JBoss Data Grid, near cache consistency is achieved by using remote events, which send notifications to clients when entries are modified or removed (refer to Remote Event Listeners (Hot Rod)). With Near Caching, local cache remains consistent with remote cache. Local entry is updated or invalidated whenever remote entry on the server is updated or removed. At the client level, near caching is configurable as either of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>DISABLED</strong> - the default mode, indicating that Near Caching is not enabled.</p>
</li>
<li>
<p><strong>INVALIDATED</strong> - enables near caching, keeping it in sync with the remote cache via invalidation messages.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/nearcache.png" alt="Near Caching" width="900">
</div>
</div>
<div class="paragraph">
<p>When should I use it?
Near caching can improve the performance of an application when most of the accesses to a given cache are read-only and the accessed dataset is relatively small. When an application is doing lots of writes to a cache, invalidations, evictions and updates to the near cache need to happen. In such a scenario near cache wont be beneficial.</p>
</div>
<div class="paragraph">
<p>For Quarkus, near caching is disabled by default, but you can enable it by setting the profile config property quarkus.infinispan-client.near-cache-max-entries to a value greater than 0. You can also configure a regular expression so that only a subset of caches have near caching applied through the quarkus.infinispan-client.near-cache-name-pattern attribute.</p>
</div>
<div class="paragraph">
<p>Add the following properties to application.properties to enable near caching.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">infinispan.client.hotrod.near_cache.mode=INVALIDATED

infinispan.client.hotrod.near_cache.max_entries=40

infinispan.client.hotrod.near_cache.cache_name_pattern=*i8n-.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lets go ahead and deploy the application to openshift.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">mvn clean package -Dquarkus.kubernetes.deploy=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should see a Build Successful message from this run as well.</p>
</div>
<div class="paragraph">
<p>Notice that any entries that you might have added to the cache prior to this deployment, they are still there, that wasnt the case in the embedded cache, since we were not using any stores and everytime the application started the cache was empty. But in this case since the cache is remote, you will still see the entries from last time. Its important to note that there are different ways you can configure and setup the cache. For more details visit the Documenatation pages for Red Hat Data Grid.</p>
</div>
</div>
<div class="sect2">
<h3 id="_caching_with_hibernate_and_jpa_and_quarkus">Caching with Hibernate and JPA and Quarkus</h3>
<div class="paragraph">
<p>When using Hibernate ORM in Quarkus, you don’t need to have a persistence.xml resource to configure it. Using such a classic configuration file is an option, but unnecessary unless you have specific advanced needs; so we’ll see first how Hibernate ORM can be configured without a persistence.xml resource.</p>
</div>
<div class="paragraph">
<p>In Quarkus, you just need to:
- add your configuration settings in application.properties
- annotate your entities with @Entity and any other mapping annotation as usual</p>
</div>
<div class="paragraph">
<p>Other configuration needs have been automated: Quarkus will make some opinionated choices and educated guesses.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.acme</span>;

<span class="annotation">@Entity</span>
<span class="annotation">@Cacheable</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Country</span> {
    <span class="comment">// ...</span>

    <span class="annotation">@OneToMany</span>
    <span class="annotation">@Cache</span>(usage = CacheConcurrencyStrategy.READ_ONLY)
    <span class="predefined-type">List</span>&lt;City&gt; cities;

    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above code just using the @Cacheable annotation will make sure that inifinspan is used as the Second Level Cache for the entities.
Also you don’t need to pick an implementation. A suitable implementation based on technologies Infinispan is included as a transitive dependency of the Hibernate ORM extension, and automatically integrated during the build.</p>
</div>
</div>
<div class="sect2">
<h3 id="_recap">Recap</h3>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>You learnt about RemoteCache and HotRod client</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>You learnt about Protostream and marshallers in Infinispan</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>You deployed you for Quarkus app using RemoteCache.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>You learnt about near caching and its usecase</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>And finally we sum it up with JPA and Second Level Cache</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><strong>*Congratulations!!</strong> you have completed the this lab on RemoteCache. Lets move to the next lab and learn how we can use the new REST API in DataGrid to our advantage.</p>
</div>
</div>
        <hr>
        <h2>REST API</h2>
        <div class="paragraph">
<p>The Data Grid REST API lets you monitor, maintain, and manage Data Grid deployments and provides access to your data.
Although the REST API has a vast amount of features that one can use, in our lab we will demonstrate some of them.
For more details on the documentation on the Red Hat Data Grid REST API. Please visit the documentation page.
Infinispan servers provide RESTful HTTP access to data through a REST endpoint built on Netty.</p>
</div>
<div class="sect2">
<h3 id="_supported_formats">Supported Formats</h3>
<div class="paragraph">
<p>You can write and read data in different formats and Data Grid can convert between those formats when required.</p>
</div>
<div class="paragraph">
<p>The following "standard" formats are interchangeable:
- application/x-java-object
- application/octet-stream
- application/x-www-form-urlencoded
- text/plain</p>
</div>
<div class="paragraph">
<p>We are using this example from the very good lists of demo collection on github: <a href="https://github.com/infinispan-demos/links" class="bare">https://github.com/infinispan-demos/links</a>
We will do the following</p>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create a Cache in infinispan with Lucene support</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We will define our protostream</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We will load bulk data into the cache</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>we will use search queries directly into the cache.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Lets get started.</p>
</div>
</div>
<div class="sect1">
<h2 id="_the_pokeman_example">The Pokeman Example</h2>
<div class="sectionbody">
<div class="paragraph">
<p>First; what is a Pokemon, incase some of us didn’t know. Reminiscences from the GameBoy the creatures that inhabit the world of Pokémon are also called Pokémon. Many species of Pokémon are capable of evolving into a larger and more powerful creature. The change is accompanied by stat changes, generally a modest increase, and access to a wider variety of attacks. There are multiple ways to trigger an evolution including reaching a particular level, using a special stone, or learning a specific attack. For example, at level 16 Bulbasaur is capable of evolving into Ivysaur. Most notably, the Normal-type Eevee is capable of evolving into eight different Pokémon: Jolteon (Electric), Flareon (Fire), Vaporeon (Water), Umbreon (Dark), Espeon (Psychic), Leafeon (Grass), Glaceon (Ice), and Sylveon (Fairy). In Generation VI, a new mechanic called Mega Evolution—as well as a subset of Mega Evolution called Primal Reversion—was introduced into the game. Unlike normal evolution, Mega Evolution and Primal Reversion last only for the duration of a battle, with the Pokémon reverting to its normal form at the end. Forty-eight Pokémon are capable of undergoing Mega Evolution or Primal Reversion as of the release of Sun and Moon. In contrast, some species such as Castform, Rotom, Unown, and Lycanroc undergo form changes that may provide stat buffs or changes and type alterations but are not considered new species. Some Pokémon have differences in appearance due to gender. Pokémon can be male or female, male-only, female-only, or genderless</p>
</div>
<div class="sect2">
<h3 id="_setup">Setup</h3>
<div class="paragraph">
<p>All the project sources are in the project dg8-restapi. We will be using Curl and our browser.</p>
</div>
<div class="paragraph">
<p>Lets open up a new terminal in the CodeReady workspace. Make sure you are logged into Openshift.</p>
</div>
<div class="paragraph">
<p>Run the following command on the terminal which will get the password for user developer and store it in and environment variable.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">    export PASSWORD=$(oc get secret datagrid-service-generated-secret -o jsonpath="{.data.identities\.yaml}" | base64 --decode | awk 'NR==3' | awk '{print $2}')</code></pre>
</div>
</div>
<div class="paragraph">
<p>So we are using the same service we created from the operator previously.</p>
</div>
<div class="paragraph">
<p>We will also need our loadbalancer address to reach the datagrid server, you can do that by running the following command in the terminal. which will set the LoadBalancer address to $LB in the terminal</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">    export LB="http://$(oc get services | grep datagrid-service-external | awk '{ print $4 }'):11222"</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>At anytime if you close the terminal, you will need to run these two commands again. To get the password and the loadbalancer</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_first_lets_register_our_protobuf">First lets register our protobuf</h3>
<div class="paragraph">
<p>By now you already know what protobuf is from previous labs as well as you might know what Pokemon’s are. Perfect time to introduce our datastructure.</p>
</div>
<div class="paragraph">
<p>Lets see whats our datastructure is like.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">/**
  * @Indexed
  */
message Pokemon  {
  repeated string abilities = 1;
  optional float against_bug = 2;
  optional float against_dark = 3;
  optional float against_dragon = 4;
  optional float against_electric = 5;
  optional float against_fairy = 6;
  optional float against_fight = 7;
  optional float against_fire = 8;
  optional float against_flying = 9;
  optional float against_ghost = 10;
  optional float against_grass = 11;
  optional float against_ground = 12;
  optional float against_ice = 13;
  optional float against_normal = 14;
  optional float against_poison = 15;
  optional float against_psychic = 16;
  optional float against_rock = 17;
  optional float against_steel = 18;
  optional float against_water = 19;
  optional int32 attack = 20;
  optional int32 base_egg_steps = 21;
  optional int32 base_happiness = 22;
  optional int32 base_total = 23;
  optional string capture_rate = 24;

  /* @Field(index=Index.YES, analyze = Analyze.YES, store = Store.NO) */
  optional string classfication = 25;
  optional int32 defense = 26;
  optional int32 experience_growth = 27;
  optional float height_m = 28;
  optional int32 hp = 29;

  /* @Field(index=Index.YES, analyze = Analyze.YES, store = Store.NO) */
  optional string japanese_name = 30;

  /* @Field(index=Index.YES, analyze = Analyze.YES, store = Store.NO) */
  optional string name = 31;
  optional float percentage_male = 32;
  optional int32 pokedex_number = 33;
  optional int32 sp_attack = 34;
  optional int32 sp_defense = 35;
  optional int32 speed = 36;

  /* @Field(index=Index.YES, analyze = Analyze.YES, store = Store.NO) */
  optional string type1 = 37;
  optional string type2 = 38;
  optional float weight_kg = 39;
  optional int32 generation = 40;
  optional int32 is_legendary = 41;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In our project <code>dg8-restapi</code> open the file pokemon.proto and paste the above datastructure. The structure defines the capabilites of a Pokemon</p>
</div>
<div class="paragraph">
<p>When caches are indexed, or specifically configured to store application/x-protostream, you can send and receive JSON documents that are automatically converted to and from Protostream.</p>
</div>
<div class="paragraph">
<p>You must register a protobuf schema for the conversion to work.</p>
</div>
<div class="paragraph">
<p>To register protobuf schemas via REST, invoke a POST or PUT in the ___protobuf_metadata cache as in the following command</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">  curl -u developer:$PASSWORD -X POST --data-binary @./pokemon.proto $LB/rest/v2/caches/___protobuf_metadata/pokemon.proto</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_create_a_cache">Create a Cache</h3>
<div class="paragraph">
<p>Now lets create an indexed cache since we want to retrieve data at speed from our Cache and Lucene store.</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">curl -u developer:$PASSWORD -H "Content-Type: application/json" -d '{"distributed-cache":{"mode":"SYNC","indexing":{"auto-config":true,"index":"ALL"}}}' $LB/rest/v2/caches/pokemon</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bulk_loading_the_rest_endpoint">Bulk loading the REST endpoint</h3>
<div class="paragraph">
<p>Now we will load all the pokemon data we have in a json format. You can view the json files in <code>dg8-restapi/data</code></p>
</div>
<div class="paragraph">
<p>for Example Abra’s capabilities listed as follows</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{
    <span class="key"><span class="delimiter">"</span><span class="content">_type</span><span class="delimiter">"</span></span>: <span class="string"><span class="delimiter">"</span><span class="content">Pokemon</span><span class="delimiter">"</span></span>,
    <span class="key"><span class="delimiter">"</span><span class="content">abilities</span><span class="delimiter">"</span></span>: <span class="string"><span class="delimiter">"</span><span class="content">['Synchronize', 'Inner Focus', 'Magic Guard']</span><span class="delimiter">"</span></span>,
    <span class="key"><span class="delimiter">"</span><span class="content">against_bug</span><span class="delimiter">"</span></span>: <span class="float">2.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">against_dark</span><span class="delimiter">"</span></span>: <span class="float">2.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">against_dragon</span><span class="delimiter">"</span></span>: <span class="float">1.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">against_electric</span><span class="delimiter">"</span></span>: <span class="float">1.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">against_fairy</span><span class="delimiter">"</span></span>: <span class="float">1.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">against_fight</span><span class="delimiter">"</span></span>: <span class="float">0.5</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">against_fire</span><span class="delimiter">"</span></span>: <span class="float">1.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">against_flying</span><span class="delimiter">"</span></span>: <span class="float">1.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">against_ghost</span><span class="delimiter">"</span></span>: <span class="float">2.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">against_grass</span><span class="delimiter">"</span></span>: <span class="float">1.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">against_ground</span><span class="delimiter">"</span></span>: <span class="float">1.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">against_ice</span><span class="delimiter">"</span></span>: <span class="float">1.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">against_normal</span><span class="delimiter">"</span></span>: <span class="float">1.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">against_poison</span><span class="delimiter">"</span></span>: <span class="float">1.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">against_psychic</span><span class="delimiter">"</span></span>: <span class="float">0.5</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">against_rock</span><span class="delimiter">"</span></span>: <span class="float">1.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">against_steel</span><span class="delimiter">"</span></span>: <span class="float">1.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">against_water</span><span class="delimiter">"</span></span>: <span class="float">1.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">attack</span><span class="delimiter">"</span></span>: <span class="float">20.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">base_egg_steps</span><span class="delimiter">"</span></span>: <span class="float">5120.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">base_happiness</span><span class="delimiter">"</span></span>: <span class="float">70.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">base_total</span><span class="delimiter">"</span></span>: <span class="float">310.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">capture_rate</span><span class="delimiter">"</span></span>: <span class="float">200.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">classfication</span><span class="delimiter">"</span></span>: <span class="string"><span class="delimiter">"</span><span class="content">Psi Pok</span><span class="char">\u00e9</span><span class="content">mon</span><span class="delimiter">"</span></span>,
    <span class="key"><span class="delimiter">"</span><span class="content">defense</span><span class="delimiter">"</span></span>: <span class="float">15.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">experience_growth</span><span class="delimiter">"</span></span>: <span class="float">1059860.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">height_m</span><span class="delimiter">"</span></span>: <span class="float">0.9</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">hp</span><span class="delimiter">"</span></span>: <span class="float">25.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">japanese_name</span><span class="delimiter">"</span></span>: <span class="string"><span class="delimiter">"</span><span class="content">Casey</span><span class="char">\u30b1</span><span class="char">\u30fc</span><span class="char">\u30b7</span><span class="char">\u30a3</span><span class="delimiter">"</span></span>,
    <span class="key"><span class="delimiter">"</span><span class="content">name</span><span class="delimiter">"</span></span>: <span class="string"><span class="delimiter">"</span><span class="content">Abra</span><span class="delimiter">"</span></span>,
    <span class="key"><span class="delimiter">"</span><span class="content">percentage_male</span><span class="delimiter">"</span></span>: <span class="float">75.4</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">pokedex_number</span><span class="delimiter">"</span></span>: <span class="float">63.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">sp_attack</span><span class="delimiter">"</span></span>: <span class="float">105.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">sp_defense</span><span class="delimiter">"</span></span>: <span class="float">55.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">speed</span><span class="delimiter">"</span></span>: <span class="float">90.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">type1</span><span class="delimiter">"</span></span>: <span class="string"><span class="delimiter">"</span><span class="content">psychic</span><span class="delimiter">"</span></span>,
    <span class="key"><span class="delimiter">"</span><span class="content">type2</span><span class="delimiter">"</span></span>: <span class="integer">0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">weight_kg</span><span class="delimiter">"</span></span>: <span class="float">19.5</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">generation</span><span class="delimiter">"</span></span>: <span class="float">1.0</span>,
    <span class="key"><span class="delimiter">"</span><span class="content">is_legendary</span><span class="delimiter">"</span></span>: <span class="float">0.0</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lets run our loading script which is placed in our project <code>dg8-restapi</code>. Run the shell script in the terminal</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">./ingest-data.sh</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The script run can take some time, wait for it to finish.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>So by now we should have loaded about 801 Pokemon’s from the Pokemon universe.</p>
</div>
<div class="paragraph">
<p>So what does the script look like?
Below you can se that we are loading each of the json files one by one to the cache rest end point</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">status=0
for f in data/*.json
do
  curl -u developer:$PASSWORD -XPOST --data-binary @${f}  -H "Content-Type: application/json; charset=UTF-8"  $LB/rest/v2/caches/pokemon/$(basename $f .json)
  let status=status+1
  echo  "Imported $f (total $status pokemons)"
done</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_query_the_data">Query the data</h3>
<div class="paragraph">
<p>Get all Pokemons:</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="url">   $LB/rest/v2/caches/pokemon?action=search&amp;query=from%20Pokemon</code></pre>
</div>
</div>
<div class="paragraph">
<p>Count Pokemons by generation:</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="url">   select count(p.name) from Pokemon group by generation
   $LB/rest/v2/caches/pokemon?action=search&amp;query=select%20count(p.name)%20from%20Pokemon%20p%20group%20by%20generation</code></pre>
</div>
</div>
<div class="paragraph">
<p>Do a full text search on the name</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="url">  $LB/rest/v2/caches/pokemon?action=search&amp;query=from%20Pokemon%20where%20name:%27pikachu%27</code></pre>
</div>
</div>
<div class="paragraph">
<p>Select top 5 Pokemons that can better withstand fire:</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="url">  $LB/rest/v2/caches/pokemon?action=search&amp;query=from%20Pokemon%20order%20by%20against_fire%20asc&amp;max_results=5</code></pre>
</div>
</div>
<div class="paragraph">
<p>Get Pokemon by key (name)</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="url">    $LB/rest/v2/caches/pokemon/Whismur</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_recap">Recap</h3>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>You how the REST API works</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>You created a cache and protobuf via REST API</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>You loaded bulk data into the cache</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>And finally you queried through that data.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><strong>*Congratulations!!</strong> you have completed the this lab on REST API!!</p>
</div>
</div>
</div>
</div>
        <hr>
        <h2>Externalizing Sessions</h2>
        <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>In this lab, we’ll develop how to externalize <strong>HTTP Sessions</strong> from <strong>Spring Boot</strong> to <strong>Data Grid</strong>. It allows Data Grid Spring Session support is built on <em>SpringRemoteCacheManager</em> and <em>SpringEmbeddedCacheManager</em> which means developers don’t need to store HTTP session data in Data Grid manually for clustering the session data across multiple Spring Boot applications. Behind the scene, Data Grid will autowire Spring Boot Session to distributed caches in Data Grid.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_1_developing_embeddedcache_service">1. Developing EmbeddedCache Service</h3>
<div class="paragraph">
<p>The <em>embeddedCache service</em> allows Spring Boot application to emded the HttpSession data at in-memory data storage when users invoke RESTful endpoints in the frontend web page. Lets’s go through quickly how the embeddedCache service gets REST services to address <strong>Spring Session</strong> with <strong>In-Memory Cache</strong> with <strong>Red Hat Data Grid 8</strong>. Go to <em>Explorer: /projects</em> in <em>CodeReady Workspaces</em> Web IDE and expand <strong>dg8-spring-session</strong> directory.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/codeready-workspace-embeddedCache-project.png" alt="embeddedCache" width="700">
</div>
</div>
<div class="paragraph">
<p>There’re a few interesting things what we need to take a look at this Spring Boot application before we will develop it in CodeReady Workspaces.</p>
</div>
<div class="paragraph">
<p>This embeddedCache service is not using the default BOM (Bill of material) that Spring Boot projects typically use. Instead, we are using an Infinispan BOM provided by Red Hat that provides a high-level API to ensure compatibility between major versions of Data Grid. You can also enforce a specific version of Data Grid with the infinispan-bom module. Let’s take a look at <strong>infinispan-bom</strong> to your <code>pom.xml</code> file as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependencyManagement&gt;</span>
    <span class="tag">&lt;dependencies&gt;</span>
        <span class="tag">&lt;dependency&gt;</span>
            <span class="tag">&lt;groupId&gt;</span>org.infinispan<span class="tag">&lt;/groupId&gt;</span>
            <span class="tag">&lt;artifactId&gt;</span>infinispan-bom<span class="tag">&lt;/artifactId&gt;</span>
            <span class="tag">&lt;version&gt;</span>${version.infinispan}<span class="tag">&lt;/version&gt;</span>
            <span class="tag">&lt;type&gt;</span>pom<span class="tag">&lt;/type&gt;</span>
            <span class="tag">&lt;scope&gt;</span>import<span class="tag">&lt;/scope&gt;</span>
        <span class="tag">&lt;/dependency&gt;</span>
        <span class="tag">&lt;dependency&gt;</span>
            <span class="tag">&lt;groupId&gt;</span>javax.transaction<span class="tag">&lt;/groupId&gt;</span>
            <span class="tag">&lt;artifactId&gt;</span>transaction-api<span class="tag">&lt;/artifactId&gt;</span>
            <span class="tag">&lt;version&gt;</span>1.1<span class="tag">&lt;/version&gt;</span>
        <span class="tag">&lt;/dependency&gt;</span>
        <span class="tag">&lt;dependency&gt;</span>
            <span class="tag">&lt;groupId&gt;</span>javax.cache<span class="tag">&lt;/groupId&gt;</span>
            <span class="tag">&lt;artifactId&gt;</span>cache-api<span class="tag">&lt;/artifactId&gt;</span>
            <span class="tag">&lt;version&gt;</span>1.1.0.redhat-1<span class="tag">&lt;/version&gt;</span>
        <span class="tag">&lt;/dependency&gt;</span>
    <span class="tag">&lt;/dependencies&gt;</span>
<span class="tag">&lt;/dependencyManagement&gt;</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/embeddedCache-pom.png" alt="embeddedCache" width="700">
</div>
</div>
<div class="paragraph">
<p>In order to use <strong>Embedded Mode</strong> in Spring Boot, <em>infinispan-spring-boot-starter-embedded</em> dependency is already pulled in your pom.xml file. This starter produces a <em>SpringEmbeddedCacheManager</em> bean by default:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>org.infinispan<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>infinispan-spring-boot-starter-embedded<span class="tag">&lt;/artifactId&gt;</span>
    <span class="tag">&lt;version&gt;</span>2.2.3.Final-redhat-00001<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/embeddedCache-pom2.png" alt="embeddedCache" width="700">
</div>
</div>
<div class="paragraph">
<p>Create an <strong>InfinispanCacheConfigurer</strong> bean to customize the cache manager. Open a Java class called <code>EmbeddedCacheService.java</code> in <em>com.redhat.com.rhdg.service</em> and copy below the <code>// TODO: Add cacheConfigurer method here</code> marker:</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">   <span class="annotation">@Bean</span>
   <span class="directive">public</span> InfinispanCacheConfigurer cacheConfigurer() {
      <span class="keyword">return</span> manager -&gt; {
         <span class="directive">final</span> <span class="predefined-type">Configuration</span> ispnConfig = <span class="keyword">new</span> ConfigurationBuilder()
               .clustering()
               .cacheMode(CacheMode.REPL_SYNC)
               .build();

         manager.defineConfiguration(<span class="string"><span class="delimiter">"</span><span class="content">sessions</span><span class="delimiter">"</span></span>, ispnConfig);
         manager.getCache(<span class="string"><span class="delimiter">"</span><span class="content">sessions</span><span class="delimiter">"</span></span>).addListener(<span class="keyword">new</span> CacheListener());

      };
   }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Copy below the <code>// TODO: Add globalCustomizer method here</code> marker to customize InfinispanGlobalConfigurer bean:</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">   <span class="annotation">@Bean</span>
   <span class="directive">public</span> InfinispanGlobalConfigurer globalCustomizer() {
      <span class="keyword">return</span> () -&gt; {
         GlobalConfigurationBuilder builder = GlobalConfigurationBuilder.defaultClusteredBuilder();
         builder.serialization().marshaller(<span class="keyword">new</span> JavaSerializationMarshaller());
         builder.transport().clusterName(<span class="string"><span class="delimiter">"</span><span class="content">rhdg</span><span class="delimiter">"</span></span>);
         builder.serialization().whiteList().addClass(<span class="string"><span class="delimiter">"</span><span class="content">org.springframework.session.MapSession</span><span class="delimiter">"</span></span>);
         builder.serialization().whiteList().addRegexp(<span class="string"><span class="delimiter">"</span><span class="content">java.util.*</span><span class="delimiter">"</span></span>);
         <span class="keyword">return</span> builder.build();
      };
   }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, Autowire <strong>cacheManager</strong> to <strong>SpringEmbeddedCacheManager</strong> then implment REST APIs to <em>createSession</em>, <em>deleteSession</em>. Copy below the <code>// TODO: Add SessionController class here</code> marker:</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@RestController</span>
        <span class="directive">static</span> <span class="type">class</span> <span class="class">SessionController</span> {

      <span class="directive">private</span> <span class="type">int</span> count = <span class="integer">0</span>;

                <span class="annotation">@Autowired</span>
                SpringEmbeddedCacheManager cacheManager;

                <span class="annotation">@RequestMapping</span>(<span class="string"><span class="delimiter">"</span><span class="content">/session</span><span class="delimiter">"</span></span>)
                <span class="directive">public</span> <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; createSession(HttpServletRequest request) {

         <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; result = <span class="keyword">new</span> <span class="predefined-type">HashMap</span>&lt;&gt;();

                        <span class="predefined-type">String</span> sessionId = request.getSession().getId();
         result.put(<span class="string"><span class="delimiter">"</span><span class="content">created:</span><span class="delimiter">"</span></span>, sessionId);
         result.put(<span class="string"><span class="delimiter">"</span><span class="content">active:</span><span class="delimiter">"</span></span>, cacheManager.getCache(<span class="string"><span class="delimiter">"</span><span class="content">sessions</span><span class="delimiter">"</span></span>).getNativeCache().keySet().toString());
         result.put(<span class="string"><span class="delimiter">"</span><span class="content">count:</span><span class="delimiter">"</span></span>, <span class="predefined-type">String</span>.valueOf(count));
         count++;

         <span class="keyword">return</span> result;

        }

      <span class="annotation">@RequestMapping</span>(<span class="string"><span class="delimiter">"</span><span class="content">/delete</span><span class="delimiter">"</span></span>)
                <span class="directive">public</span> <span class="type">void</span> deleteSession(HttpServletRequest request) {

         request.getSession().invalidate();
         count = <span class="integer">0</span>;

                }
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Add the <strong>@EnableInfinispanEmbeddedHttpSession</strong> annotation to <em>EmbeddedCacheService</em> to enable Spring Cache support. When this starter detects the EmbeddedCacheManager bean, it instantiates a new SpringEmbeddedCacheManager, which provides an implementation of <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/cache.html" target="_blank" rel="noopener">Spring Cache</a>.</p>
</div>
<div class="paragraph">
<p>Copy below the <code>// TODO: Add an Infinispan annotation here</code> marker:</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EnableInfinispanEmbeddedHttpSession</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Perfect!</strong> Now we have all the building blocks ready to use the cache. Let’s start using our cache.</p>
</div>
</div>
<div class="sect2">
<h3 id="_2_deploying_embeddedcache_service">2. Deploying EmbeddedCache Service</h3>
<div class="paragraph">
<p>Now we will build and deploy the project using the following command, which will use the maven plugin to deploy via CodeReady Workspaces Terminal:</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">mvn clean package spring-boot:repackage -f $CHE_PROJECTS_ROOT/cdg8-workshop/dg8-spring-session</code></pre>
</div>
</div>
<div class="paragraph">
<p>Create a build configuration for your application using OpenJDK base container image in OpenShift:</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">oc new-build registry.access.redhat.com/redhat-openjdk-18/openjdk18-openshift:1.5 --binary --name=cacheapp -l app=cacheapp</code></pre>
</div>
</div>
<div class="paragraph">
<p>Start and watch the build, which will take about minutes to complete:</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">oc start-build cacheapp --from-file=target/rhdg-0.0.1-SNAPSHOT.jar --follow</code></pre>
</div>
</div>
<div class="paragraph">
<p>Deploy it as an OpenShift application after the build is done:</p>
</div>
<div class="listingblock copypaste">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">oc new-app cacheapp &amp;&amp; oc expose svc/cacheapp &amp;&amp; \
oc label dc/cacheapp app.kubernetes.io/part-of=catalog app.openshift.io/runtime=spring --overwrite</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, make sure it’s actually done rolling out. Visit the <a href="https://console-openshift-console.apps.cluster-cph-b051.cph-b051.example.opentlc.com/topology/ns/user19-cache" target="_blank" rel="noopener">Topology View</a> for the cache service, and ensure you get the blue circles!</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/embeddedCache-topology.png" alt="embeddedCache" width="500">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_3_testing_embeddedcache_service">3. Testing EmbeddedCache Service</h3>
<div class="paragraph">
<p>Let’s scale up the cache service to make sure if the clustered Spring applications refer to <em>Spring Session</em> in Data Grid. Click on <code>Up Arrow</code> once in <em>Overview</em> page:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/embeddedCache-scaleup-start.png" alt="embeddedCache" width="700">
</div>
</div>
<div class="paragraph">
<p>Then you will see how the pod is scailing up:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/embeddedCache-scaleup-end.png" alt="embeddedCache" width="700">
</div>
</div>
<div class="paragraph">
<p>Let’s go externalizing Spring Session to Data Grid! Access the <a href="http://cacheapp-user19-cache.apps.cluster-cph-b051.cph-b051.example.opentlc.com/" target="_blank" rel="noopener">Cache Service UI</a>!</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/embeddedCache-ui.png" alt="embeddedCache" width="700">
</div>
</div>
<div class="paragraph">
<p>Click on <code>Invoke the service</code> then the <strong>created</strong> <em>Spring Session ID</em> is already stored at in-memory datagrid as <strong>active</strong> data in the <em>Result</em> box:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/embeddedCache-invoke1.png" alt="embeddedCache" width="700">
</div>
</div>
<div class="paragraph">
<p>Open a new web browser window then access the the <a href="http://cacheapp-user19-cache.apps.cluster-cph-b051.cph-b051.example.opentlc.com/" target="_blank" rel="noopener">Cache Service UI</a>.</p>
</div>
<div class="paragraph">
<p>Click on <code>Invoke the service</code> once again then you will see the exact same <em>Spring Session ID</em> and <em>active data</em> but the <strong>count</strong> is increased to <code>2</code>. So two applications are clustered and refer to the *embedded Infinispan cache:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/embeddedCache-invoke2.png" alt="embeddedCache" width="700">
</div>
</div>
<div class="paragraph">
<p>Go back to the <strong>first</strong> web browser then click on <code>Clear the cache</code>. Move to the <strong>second</strong> web browser then click on <code>Invoke the service</code>.
You will see new <strong>Session ID</strong>, <strong>active data</strong> and the count is reset to <strong>1</strong> again:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/embeddedCache-invoke3.png" alt="embeddedCache" width="700">
</div>
</div>
<div class="paragraph">
<p>Let’s double-check if the Spring Session is clustered in the all running pods. Go back to the <a href="https://console-openshift-console.apps.cluster-cph-b051.cph-b051.example.opentlc.com/topology/ns/user19-cache" target="_blank" rel="noopener">Topology View</a> and click on 'View logs' in the pods:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/embeddedCache-invoke4.png" alt="embeddedCache" width="700">
</div>
</div>
<div class="paragraph">
<p>Now that we know how to react on changes in the cluster topology, we can also react to changes to the data within the cluster. The <strong>CacheListener</strong> separates the roles of our two pods such as putting data in the cache(<em>-- Entry for CACHE_ENTRY_MODIFIED created</em>) and showing the cache modifications(<em>-- Entry for CACHE_ENTRY_MODIFIED modified</em>):</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Red Hat Data Grid - From zero to hero_files/embeddedCache-logs.png" alt="embeddedCache" width="700">
</div>
</div>
<div class="paragraph">
<p>We now have implemented Spring Session with embedded in-memory datagrid for clustering HTTP sessions across Spring Boot microservices. <strong>Congratulations!</strong></p>
</div>
</div>
        <hr>
        <h2>You made it!</h2>
        <div class="sect1">
<h2 id="_conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You made it ! Or you jumped to this section. Anyway, congratulations. We hope you enjoy this lab and learn some
<em>stuff</em>. There is many other things about Red Hat Data Grid and Inifinispan that you can do and that was not illustrated here.</p>
</div>
<div class="paragraph">
<p>Don’t forget Red Hat Data Grid can be used in many usecases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Red Hat Data Grid is a Cloud native caching system that you can embed in your application or use it as a remote server</p>
</li>
<li>
<p>You can use it with the some of the well known frameworks and runtimes like Java, Node, C, C# etc.</p>
</li>
<li>
<p>And it intergrates very well with Kubernetes/Openshift e.g. Operators, Observability etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As soon as you jump into the microservice, functions or cloud native applications, you will need a better application environment. Kubernetes/OpenShift are perfect weapon to build, deploy, bind, and manage your microservices.</p>
</div>
<div class="paragraph">
<p>If you want, and we hope so, to go further here are some references:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Traditional zip deployments are available on the <a href="https://access.redhat.com/" target="_blank" rel="noopener">Customer Portal</a>.</p>
</li>
<li>
<p>The container distribution and operator are available in the <a href="https://catalog.redhat.com/software/containers/explore" target="_blank" rel="noopener">Red Hat Container Catalog</a></p>
</li>
<li>
<p>Product documentation is available <a href="https://docs.redhat.com/" target="_blank" rel="noopener">here</a></p>
</li>
<li>
<p>Getting Started Guide that will get you running with RHDG 8 in 5 minutes.</p>
</li>
<li>
<p><a href="https://access.redhat.com/documentation/en-us/red_hat_data_grid/8.0/html/data_grid_migration_guide/index" target="_blank" rel="noopener">Migration Guide</a></p>
</li>
<li>
<p><a href="https://github.com/redhat-developer/redhat-datagrid-tutorials" target="_blank" rel="noopener">Starter Tutorials</a></p>
</li>
<li>
<p><a href="https://access.redhat.com/articles/4933371" target="_blank" rel="noopener">Supported Components</a></p>
</li>
<li>
<p><a href="https://access.redhat.com/articles/4933551" target="_blank" rel="noopener">Supported Configurations</a></p>
</li>
</ul>
</div>
</div>
</div>
        <hr>
        <h2>Setting up your own environment</h2>
        <div class="sect1">
<h2 id="_appendix_setting_up_my_own_machine_for_the_lab">APPENDIX: Setting up my own machine for the lab</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The labs are designed to run entirely on openshift, there is no mandatory requirement to install the following components. The following instructions are means of guidance for anyone who wants to try them out on their own machine.</p>
</div>
<div class="paragraph">
<p>*Recommended path is to use the Openshift RHMI/Integreatly environment provided in this workshop.</p>
</div>
<div class="sect2">
<h3 id="_java_development_kit">Java Development Kit</h3>
<div class="paragraph">
<p>We need a JDK 8+ installed on our machine. Latest JDK can downloaded from:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">Oracle JDK 8</a></p>
</li>
<li>
<p><a href="http://openjdk.java.net/install/">OpenJDK</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can use either Oracle JDK or OpenJDK.</p>
</div>
</div>
<div class="sect2">
<h3 id="_apache_maven">Apache Maven</h3>
<div class="paragraph">
<p>You need Apache Maven 3.5+. If you don’t have it already:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Download Apache Maven from <a href="https://maven.apache.org/download.cgi" class="bare">https://maven.apache.org/download.cgi</a>.</p>
</li>
<li>
<p>Unzip to a directory of your choice and add it to the <code>PATH</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_ide">IDE</h3>
<div class="paragraph">
<p>We recommend you use an IDE. You can use Eclipse, IntelliJ, VS Code or Netbeans.</p>
</div>
<div class="sect3">
<h4 id="_no_ide">No IDE ?</h4>
<div class="paragraph">
<p>If you don’t have an IDE, here are the steps to get started with Eclipse.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>First download Eclipse from <a href="http://www.eclipse.org/downloads/packages/eclipse-ide-java-developers/oxygen1">the download page</a>.</p>
</li>
<li>
<p>In the <em>Download Links</em> section, be sure to select the right version for your operating system. Once selected it brings you to a download page with a
<code>Download</code> button.</p>
</li>
<li>
<p>Once downloaded, unzip it.</p>
</li>
<li>
<p>In the destination directory, you should find an <code>Eclipse</code> binary that you can execute.</p>
</li>
<li>
<p>Eclipse asks you to create a workspace.</p>
</li>
<li>
<p>Once launched, click on the <em>Workbench</em> arrow (top right corner).</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_getting_the_code">Getting the code</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>git clone https://github.com/jbossdemocentral/sso-kubernetes-workshop.git</code></pre>
</div>
</div>
</div>
</div>
</div>
        <hr>
        <h2>References</h2>
        <div class="sect1">
<h2 id="_references">References</h2>
<div class="sectionbody">

</div>
</div>
        <hr>
    </div>
  </div>
</main>



</body></html>